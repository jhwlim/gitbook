---
description: 이펙티브 코틀린 정리하기
---

# 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라

Iterable과 Sequence는 완전히 다른 목적으로 설계되어서, 완전히 다른 형태로 동작한다.

Iterable은 처리 함수를 사용할 때마다 연산이 이루어져 List가 만들어진다. 즉, 호출할 때 연산이 이루어진다.

Sequence는 지연(lazy) 처리된다. 따라서 시퀀스 처리 함수들을 사용하면, 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴된다. 최종적인 계산은 `toList` 또는 `count` 등의 최종 연산이 이루어질 때 수행된다. 즉, 최종 연산이 이루어지기 전까지는 각 단계에서 연산이 일어나지 않는다.

## 장점

### 자연스러운 처리 순서를 유지한다

Iterable 처리와 Sequence 처리는 연산의 순서가 달라지면, 다른 결과가 나온다.

시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용한다. 이를 전문적으로 element-by-element order 또는 lazy order 라고 부른다.

```kotlin
sequenceOf(1, 2, 3)
    .filter {
        print("F$it, ")
        it % 2 == 1
    }
    .map {
        print("M$it, ")
        it * 2
    }
    .forEach { print("E$it, ") }
// 출력 : F1, M1, E2, F2, F3, M3, E6,
```

반면에 Iterable은 요소 전체를 대상으로 연산을 차근차근 적용해 나간다. 이를 전문적으로 step-by-step order 또는 eager order 라고 부른다.

```kotlin
listOf(1, 2, 3)
    .filter {
        print("F$it, ")
        it % 2 == 1
    }
    .map {
        print("M$it, ")
        it * 2
    }
    .forEach { print("E$it, ") }
// 출력 : F1, F2, F3, M1, M3, E2, E6,
```

시퀀스 처리에서 사용되는 element-by-element order가 훨씬 자연스러운 처리라고 할 수 있다.

### 최소한만 연산한다

{% hint style="success" %}
중간 처리 단계를 모든 요소에 적용할 필요가 없는 경우에는 시퀀스를 사용하는 것이 좋다.
{% endhint %}

```kotlin
(1..10).asSequence()
    .filter { 
        print("F$it, ")
        it % 2 == 1
    }
    .map { 
        print("M$it, ")
        it * 2
    }
    .find { it > 5 }
// 출력 : F1, M1, F2, F3, M3,

(1..10).
    .filter { 
        print("F$it, ")
        it % 2 == 1
    }
    .map { 
        print("M$it, ")
        it * 2
    }
    .find { it > 5 }
// 출력 : F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, M1, M3, M5, M7, M9,
```

### 무한 시퀀스 형태로 사용할 수 있다

시퀀스는 실제로 최종 연산이 일어나기 전까지는 컬렉션에 어떠한 처리도 하지 않는다. 따라서 무한 시퀀스를 만들고, 필요한 부분까지만 값을 추출하는 것도 가능하다. 

무한 시퀀스를 만드는 일반적인 방법

(1) `generateSequence('첫 번째 요소', '그 다음 요소를 계산하는 방법')`

```kotlin
generateSequence(1) { it + 1 }
    .map { it * 2 }
    .take(10)
    .forEach { print("$it, ") }
// 출력 : 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,

```

(2) `sequence()`

중단 함수(suspending function, 코루틴)로 요소들을 지정한다.

시퀀스 빌더는 중단 함수 내부에서 `yield`로 값을 하나씩 만들어 낸다.

```kotlin
val fibonacci = sequence {
    yield(1)
    var current = 1
    var prev = 1
    while (true) {
        yield(current)
        val temp = prev
        prev = current
        current += temp
    }
}

print(fibonacci.take(10).toList()) // [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

값을 몇 개 활용할지 지정해야 한다. 그렇지 않으면 무한하게 반복한다.

```kotlin
print(fibonacci.toList()) // 종료되지 않는다.
```

{% hint style="warning" %}
다만 실제로 사용해 보면, 무한 반복에 빠지는 경우가 생각보다 많다. 결과적으로 무한 시퀀스는 종결 연산으로 `take`와 `first` 정도만 사용하는 것이 좋다.
{% endhint %}


### 각각의 단계에서 컬렉션을 만들어 내지 않는다

컬렉션 처리의 각각의 단계에서 새로운 컬렉션을 만드는 데는 비용이 들어간다. 크기가 큰 요소를 처리할수록 비용이 커진다. 처리 단계가 하나 정도라면, 컬렉션 처리와 시퀀스 처리의 차이가 크지 않다. 하지만 처리 단계가 많아질수록 이러한 차이가 커지므로, 큰 컬렉션으로 여러 처리 단계를 거쳐야 한다면, 컬렉션 처리보다는 시퀀스 처리를 사용하는 것이 좋다.

필자의 경험으로는 하나 이상의 처리 단계를 포함하는 컬렉션 처리는 20~40% 정도의 성능이 향상된다.

## 시퀀스가 빠르지 않은 경우

컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않는다. (예 : `sorted`)

{% hint style="info" %}
무한 시퀀스에 `sorted`를 사용할 수 없다.
{% endhint %}

`sorted`는 Sequence보다 Collection이 더 빠른 희귀한 예이다. 다른 처리는 모두 Sequence가 빠르므로, 여러 처리가 결합된 경우에는 Collection을 사용하는 것보다 Sequence를 사용하는 것이 더 빠르다.

## 자바 스트림의 경우

자바 8부터는 컬렉션 처리를 위해 스트림 기능이 추가되었다. 코틀린 시퀀스와 비슷한 형태로 동작한다.

자바 8의 스트림도 lazy하게 작동하며, 마지막 처리 단계에서 연산이 일어난다.

### 자바 스트림 vs 코틀린 시퀀스

- 코틀린의 시퀀스가 더 많은 처리 함수를 갖고 있다. (확장 함수를 사용해서 정의되어 있음.)
- 사용하기 더 쉽다. (`collect(Collectors.toList())` vs. `toList()`)
- 자바 스트림은 병렬 함수를 사용해서 병렬 모드로 실행할 수 있다. 멀티 코어 환경에서 굉장히 큰 성능 향상을 가져온다. 다만 몇 가지 결함이 있으므로 주의해서 사용해야 한다.
- 코틀린의 시퀀스는 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등의 일반적인 모듈에서 모두 사용할 수 있다. 하지만 자바 스트림은 코틀린/JVM에서만 동작하며, 그것도 JVM이 8 버전 이상일 때만 동작한다.

{% hint style="info" %}
병렬 함수 내부에서 사용하는 common join-fork 스레드 풀과 관련된 이슈가 있다. 병렬로 처리되는 작업이 독립적인 처리가 아니라면, 성능에 문제가 발생한다.
{% endhint %}

{% hint style="success" %}
병렬 모드로 성능적 이득을 얻을 수 있는 곳에서만 자바 스트림을 사용하고, 이외의 일반적인 경우에는 코틀린 시퀀스를 사용하는 것이 좋다.
{% endhint %}

## 코틀린 시퀀스 디버깅

코틀린 시퀀스와 자바 스트림은 모두 단계적으로 요소의 흐름을 추적할 수 있는 디버깅 기능이 지원된다.

- 자바 : Java Stream Debugger
- 코틀린 : Kotlin Sequence Debugger (현재 Kotlin 플러그인과 통합됨.)

## 정리

컬렉션과 시퀀스는 같은 처리 메서드를 지원하며, 사용하는 형태가 거의 비슷하다.

장점

- 자연스러운 처리 순서를 유지한다.
- 최소한만 연산한다.
- 무한 시퀀스 형태로 사용할 수 있다.
- 각각의 단계에서 컬렉션을 만들어 내지 않는다.

단점

- 일반적으로 데이터를 컬렉션에 저장하므로, 시퀀스 처리를 하려면 시퀀스로 변환하는 과정이 필요하다.
- 최종적으로 컬렉션 결과를 원하는 경우가 많으므로, 시퀀스를 다시 컬렉션으로 변환하는 과정도 필요하다.

결과적으로 무거운 객체나 규모가 큰 컬렉션을 여러 단계에 걸쳐서 처리할 때는 시퀀스를 사용하는 것이 좋다. 상황에 따라서 시퀀스 처리를 활용하면 큰 성능 향상이 있을 수 있다.