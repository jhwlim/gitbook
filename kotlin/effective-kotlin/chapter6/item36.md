---
description: 이펙티브 코틀린 정리하기
---

# 상속보다는 컴포지션을 사용하라 

상속은 `is-a` 관계의 객체 계층 구조를 만들기 위해 설계되었다. 상속은 관계가 명확하지 않을 때 사용하면, 여러 가지 문제가 발생할 수 있다.

{% hint style="success" %}
따라서 단순하게 코드 추출 또는 재사용을 위해 상속을 하려고 한다면, 조금 더 신중하게 생각해야 한다. 일반적으로 이러한 경우에는 상속보다 컴포지션을 사용하는 것이 좋다.
{% endhint %}

## 간단한 행위 재사용

### 상속의 단점

- 상속은 하나의 클래스만을 대상으로 할 수 있다. 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어진다.
- 상속은 클래스의 모든 것을 가져오게 된다. 따라서 불필요한 함수를 갖는 클래스가 만들어질 수 있다. (인터페이스 분리 원칙을 위반하게 된다.)
- 상속은 이해하기 어렵다. 일반적으로 개발자가 메서드를 읽고, 메서드의 작동 방식을 이해하기 위해 슈퍼클래스를 여러 번 확인해야 한다면, 문제가 있는 것이다.


이러한 이유 떄문에 다른 대안을 사용하는 것이 좋다. 대표적인 대안이 컴포지션이다. 

### 컴포지션

컴포지션을 사용한다는 것은 **객체를 프로퍼티로 갖고, 함수를 호출하는 형태로 재사용하는 것을 의미한다.**

객체를 다른 모든 객체에서 갖고 활용하는 추가 코드가 필요하다. 이러한 추가 코드를 적절하게 처리하는 것이 조금 어려울 수도 있어 컴포지션보다 상속을 선호하는 경우도 많다.

하지만 이런 추가 코드로 인해서 코드를 읽는 사람들이 코드의 실행을 더 명확하게 예측할 수 있다는 장점도 있고, 훨씬 자유롭게 사용할 수 있다는 장점이 있다. 또한 하나의 클래스 내부에서 여러 기능을 재사용할 수 있게 된다.

## 모든 것을 가져올 수 밖에 없는 상속

상속은 슈퍼클래스의 메서드, 제약, 행위 등 모든 것을 가져온다. 따라서 상속은 객체의 계층 구조를 나타낼 때 굉장히 좋은 도구이다. 하지만 일부분을 재사용하기 위한 목적으로는 적합하지 않다. 

{% hint style="success" %}
일부분만 재사용하고 싶다면, 컴포지션을 사용하는 것이 좋다. 컴포지션은 우리가 원하는 행위만 가져올 수 있기 때문이다.
{% endhint %}

```kotlin
abstract class Dog {
    open fun bark() { ... }
    open fun sniff() { ... }
}

class RobotDog : Dog() {
    override fun sniff() {
        throw Error("Operation not supported")
    }
}
```
- `RobotDog`는 필요도 없는 메서드를 갖기 때문에, 인터페이스 분리 원칙에 위반된다.
- 또한, 슈퍼클래스의 동작을 서브클래스에서 깨버리므로, 리스코프 치환 원칙에도 위반된다.

만약 타입 계층 구조를 표현해야 한다면, 인터페이스를 활용해서 다중 상속을 하는 것이 좋을 수도 있다.

