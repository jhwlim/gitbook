---
description: 이펙티브 코틀린 정리하기
---

# hashCode의 규약을 지켜라

`hashCode` 함수는 수많은 컬렉션과 알고리즘에 사용되는 자료 구조인 해시 테이블을 구축할 때 사용된다.

## 해시 테이블

배열 또는 링크드 리스트를 기반으로 만들어진 컬렉션은 요소가 포함되어 있는지 확인하는 성능이 좋지 않다. 요소가 포함되어 있는지 확인할 때 하나하나 모든 요소와 비교해야 하기 때문이다.

성능을 좋게 만드는 해결 방법이 바로 해시 테이블이다. 해시 테이블은 각 요소에 숫자를 할당하는 함수가 필요하다. 이 함수를 해시 함수라고 부르며, 같은 요소라면 항상 같은 숫자를 리턴한다

### 해시 함수

특성

- 빠르다.
- 충돌이 적다. (다른 값이라면 최대한 다른 숫자를 리턴한다는 의미이다.)

해시 함수는 각각의 요소에 특정한 숫자를 할당하고, 이를 기반으로 요소를 다른 버킷에 넣는다. 또한 해시 함수의 기본적인 조건(같은 요소라면 항상 같은 숫자를 리턴한다.)에 의해서, 같은 요소는 항상 동일한 버킷에 넣게 된다. 버킷은 버킷 수와 같은 크기의 배열인 해시 테이블에 보관된다.

요소를 추가하는 경우에는 해시 함수로 배치할 버킷을 계산하고, 이 버킷 안에 요소를 추가한다. (버킷은 배열처럼 구현된다.)

요소를 찾는 경우에도 해시 함수로 만들어지는 숫자를 활용해 버킷을 찾은 뒤, 버킷 내부에서 원하는 요소를 찾는다.

## 가변성과 관련된 문제

요소가 추가될 때만 해시 코드를 계산한다. 요소가 변경되어도 해시 코드는 계산되지 않으며, 버킷 재배치도 이뤄지지 않는다.

{% hint style="warning" %}
기본적인 `LinkedHashSet`와 `LinkedHashMap`의 키는 한 번 추가한 요소를 변경할 수 없다.
{% endhint %}

{% hint style="danger" %}
해시 등의 'mutable 프로퍼티로 요소를 조합하는 자료 구조'에서는 mutable 객체가 사용되지 않는다.

Set과 Map의 키로 mutable 요소를 사용하면 안 되며, 사용하더라도 요소를 변경해서는 안 된다. 이러한 이유로 immutable 객체를 많이 사용한다.
{% endhint %}

## hashCode의 규약

> **`hashCode` 규약 (코틀린 1.3.11 기준)**
>
> - 어떤 객체를 변경하지 않았다면(equals에서 비교에 사용된 정보가 수정되지 않는 이상), `hashCode`는 여러 번 호출해도 그 결과가 항상 같아야 한다.
> - `equals` 메서드의 실행 결과로 두 객체가 같다고 나온다면, `hashCode` 메서드의 호출 결과도 같다고 나와야 한다.

`hashCode`는 `equals`와 같이 일관성 있는 동작을 해야 한다. 즉, 같은 요소는 반드시 같은 해시 코드를 가져야 한다. 그렇지 않으면 컬렉션 내부에 요소가 들어 있는지 제대로 확인하지 못하는 문제가 발생한다. 그래서 코틀린은 `equals` 구현을 오버라이드할 때, `hashCode`도 함께 오버라이드하는 것을 추천한다.

필수 요구 사항은 아니지만 제대로 사용하려면 지켜야 하는 요구사항이 있다. 바로 `hashCode`는 최대한 요소를 넓게 퍼뜨려야 한다는 것이다. 다른 요소라면 최대한 다른 해시 값을 갖는 것이 좋다.

## hashCode 구현하기

일반적으로 data 한정자를 붙이면, 코틀린이 알아서 적당한 `equals`와 `hashCode`를 정의해주므로 이를 직접 정의할 일은 거의 없다.

다만 `equals`를 따로 정의했다면, 반드시 `hashCode`도 함께 정의해줘야 한다. `equals`를 따로 정의하지 않았다면, 정당한 이유가 없는 이상 `hashCode`를 따로 정의하지 않는 것이 좋다.

`equals`로 같은 요소라고 판정되는 요소는 `hashCode`가 반드시 같은 값을 리턴해야 한다.

`hashCode`는 기본적으로는 `equals`에서 비교에 사용되는 프로퍼티를 기반으로 해시 코드를 만들어야 한다.

### hashCode를 만드는 방법

일반적으로 모든 해시 코드의 값을 더한다. 더하는 과정마다 이전까지의 결과에 31을 곱한 뒤 더해 준다. (관례적으로 31을 많이 사용한다.)

이때 유용한 함수로는 코틀린/JVM의 `Objects.hashCode`가 있다. 이 함수는 해시를 계산해준다.

{% hint style="success" %}
`hashCode`를 구현할 때 가장 중요한 원칙은 '언제나 `equals`와 일관된 결과가 나와야 한다'이다. 같은 객체라면 언제나 같은 값을 리턴하게 만들어야 한다.
{% endhint %}
