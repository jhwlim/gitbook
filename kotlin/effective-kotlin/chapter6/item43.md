---
description: 이펙티브 코틀린 정리하기
---

# API의 필수적이지 않는 부분을 확장 함수로 추출하라

클래스의 메서드를 정의할 때는 메서드를 멤버로 정의할 것인지 아니면 확장 함수로 정의할 것인지 결정해야 한다.

```kotlin
// 멤버로 메서드 정의하기
class Workshop(/*...*/) {
    // ...

    fun makeEvent(date: DateTime): Event = //...

    val permalink
        get() = "/workshop/$name"
}
```

```kotlin
// 확장 함수로 메서드 정의하기
class Workshop(/*...*/) {
    // ...
}

fun WorkShop.makeEvent(date: DateTime): Event = //...

val Workshop.permalink
    get() = "/workshop/$name"

```

두 방식은 장단점을 모두 갖고 있으므로 상황에 맞게 사용해야 한다.

## 멤버와 확장의 차이점

### 확장은 따로 가져와서 사용해야 한다.

일반적으로 확장은 다른 패키지에 위치한다.

확장은 직접 멤버를 추가할 수 없는 경우, 데이터와 행위를 분리하도록 설계된 프로젝트에서 사용된다. 필드가 있는 프로퍼티는 클래스에 있어야 하지만, 메서드는 클래스의 public API만 활용한다면 어디에 위치해도 상관없다.

### 멤버는 높은 우선순위를 가진다.

import해서 사용한다는 특징 덕분에 확장은 같은 타입에 같은 이름으로 여러 개 만들 수도 있다. 따라서 여러 라이브러리에서 여러 메서드를 받을 수도 있고, 충돌이 발생하지 않는다는 장점이 생긴다. 하지만 같은 이름으로 다른 동작을 하는 확장이 있다는 것은 위험할 수 있다. 

위험 가능성이 있다면, 그냥 멤버 함수로 만들어서 사용하는 것이 좋다. 그렇게 하면 컴파일러가 항상 확장 대신 멤버 함수를 호출할 것이다.

### 확장은 가상이 아니다.

파생 클래스에서 오버라이드할 수 없다. 확장 함수는 컴파일 시점에 정적으로 선택된다. 따라서 확장 함수는 가상 멤버 함수와 다르게 동작한다.

```kotlin
open class C
class D : C()
fun C.foo() = "c"
fun D.foo() = "d"

fun main() {
    val d = D()
    println(d.foo()) // d
    
    val c: C = d
    println(c.foo()) // c

    println(c.foo()) // c
    println(D().foo()) // d
    println((D() as C).foo()) // c
}
```

이러한 차이는 확장 함수가 '첫 번째 아규먼트로 리시버가 들어가는 일반 함수'로 컴파일되기 때문에 발생되는 결과이다.

{% hint style="warning" %}
상속을 목적으로 설계된 요소는 확장 함수로 만들면 안 된다.
{% endhint %}

### 확장 함수는 클래스가 아닌 타입에 정의하는 것이다.

nullable 또는 구체적인 제네릭 타입에도 확장 함수를 정의할 수 있다.

### 확장은 클래스 레퍼런스에서 멤버로 표시되지 않는다.

확장 함수는 어노테이션 프로세서가 따로 처리하지 않는다. 따라서 필수적이지 않은 요소를 확장 함수로 추출하면, 어노테이션 프로세스로부터 숨겨진다.

## 정리

멤버와 확장 함수의 차이점

- 확장 함수는 읽어 들어야 한다.
- 확장 함수는 가상이 아니다.
- 멤버는 높은 우선순위를 가진다.
- 확장 함수는 클래스 위가 아니라 타입 위에 만들어진다.
- 확장 함수는 클래스 레퍼런스에 나오지 않는다.

확장 함수는 더 많은 자유와 유연성을 준다. 확장 함수는 상속, 어노테이션 처리 등을 지원하지 않고, 클래스 내부에 없으므로 약간 혼동을 줄 수 있다. 

{% hint style="success" %}
API의 필수적인 부분은 멤버로 두는 것이 좋지만, 필수적이지 않은 부분은 확장 함수로 만드는 것이 좋다.
{% endhint %}
