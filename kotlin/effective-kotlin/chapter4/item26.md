---
description: 이펙티브 코틀린 정리하기
---

# 함수 내부의 추상화 레벨을 통일하라

계층이 잘 분리되면 어떤 계층에서 작업하더라도 그 아래 계층은 이미 완성되어 있으므로, 해당 계층만 생각하면 된다. 즉, 전체를 이해할 필요가 없어진다.

## 추상화 레벨

프로그래밍에서는 일반적으로 높은 레벨일수록 프로세서로부터 멀어진다고 표현한다. 높은 레벨일수록 걱정해야 하는 세부적인 내용들이 적다. **높은 레벨일수록 단순함을 얻지만, 제어력(control)을 잃는다.**

## 추상화 레벨 통일

코드도 추상화를 계층처럼 만들어서 사용할 수 있다. 이를 위한 기본적인 도구가 바로 함수이다.

### 추상화 레벨 통일 원칙 (Single Level of Abstraction, SLA)

{% hint style="success" %}
함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다.
{% endhint %}

한 함수에 여러 로직을 구현할 수 있다. 이런 함수는 함수를 읽으면서 세부적인 내용을 하나하나 신경 써야 하므로, 읽고 이해하는 것이 거의 불가능에 가깝다.

그래서 최근에는 함수를 계층처럼 나누어서 사용한다.

```kotlin
fun makeCoffee() {
    boilWater()
    brewCoffee()
    pourCoffee()
    pourMilk()
}

private fun boilWater() { ... }
private fun brewCoffee() { ... }
private fun pourCoffee() { ... }
private fun pourMilk() { ... }
```


{% hint style="success" %}
함수는 작아야 하며, 최소한의 책임만을 가져야 한다.
{% endhint %}

또한 어떤 함수가 다른 함수보다 좀 복잡하다면, 일부 부분을 추출해서 추상화하는 것이 좋다. 추가적으로 이런 형태로 함수를 추출하면, **재사용과 테스트가 쉬워진다.**

## 프로그램 아키텍처의 추상 레벨

추상화 계층이라는 개념은 함수보다 높은 레벨에서도 적용할 수 있다.

추상화를 구분하는 이유는 서브시스템의 세부 사항을 숨김으로써 상호 운영성(interoperability)과 플랫폼 독립성을 얻기 위함이다. 이는 문제 중심으로 프로그래밍한다는 의미이다.

이러한 개념은 모듈 시스템을 설계할 때도 중요하다. 모듈을 분리하면 계층 고유의 요소를 숨길 수 있다.

계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 보아도, 일반적인 관점을 얻을 수 있다.

## 정리

별도의 추상화 계층을 만드는 것은 knowledge를 체계화하고, 서브시스템의 세부 사항을 숨김으로써 상호 운영성(interoperability)과 플랫폼 독립성을 얻게한다. 함수, 클래스, 모듈 등의 다양한 방식을 통해서 추상화를 분리한다.

이때 각각의 레이어가 너무 커지는 것이 좋지 않다. 작고 최소한의 책임만 갖는 함수가 이해하기 쉽다.

추상화 레벨은 구체적인 동작, 프로세서, 입출력과 가까울수록 낮은 레벨이라고 표현한다. 낮은 추상화 계층에서는 높은 계층에서 사용하는 요소(API)를 만든다.