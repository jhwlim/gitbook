---
description: 이펙티브 코틀린 정리하기
---

# 변화로부터 코드를 보호하려면 추상화를 사용하라

함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있다.

그리고 이후에 실질적인 코드를 원하는대로 수정할 수도 있다.

추상화의 균형을 맞추는 방법

- 상수
- 함수
- 클래스

## 상수

리터럴은 아무것도 설명하지 않는다. 따라서 코드에서 반복적으로 등장할 때 문제가 된다.

이러한 리터럴은 상수 프로퍼티로 변경하면 해당 값에 의미 있는 이름을 붙일 수 있으며, 상수의 값을 변경해야 할 때 쉽게 변경할 수 있다.

{% hint style="success" %}
두 번 이상 사용되는 값은 상수로 추출하는 것이 좋다.
{% endhint %}

### 장점

- 이름을 붙일 수 있다.
- 나중에 해당 값을 쉽게 변경할 수 있다.

## 함수

{% hint style="danger" %}
내부적으로만 사용하더라도, 함수의 이름을 직접 바꾸는 것은 위험할 수 있다. 
{% endhint %}

다른 모듈이 해당 함수에 의존하고 있다면, 다른 모듈에 큰 문제가 발생할 것이다.

컴파일러의 관점에서는 큰 차이가 없지만, 사람의 관점에서는 이름이 바뀌면 큰 변화가 일어난 것이다. **함수는 추상화를 표현하는 수단이며, 함수 시그니처는 해당 함수가 어떤 추상화를 표현하고 있는지를 알려준다. 따라서 의미 있는 이름은 굉장히 중요하다.**

### 단점
- 함수는 상태를 유지하지 않는다.
- 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있다.

## 클래스

클래스는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다.

의존성 주입 프레임워크를 사용하면, 클래스 생성을 위임할 수도 있다.

```kotlin
@Inject lateinit var messageDisplay: MessageDisplay
```

또한 mock 객체를 활용해서 해당 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있다.

```kotlin
val messageDisplay: MessageDisplay = mockk()
```

더 다양한 종류의 메서드를 만들 수도 있다.

```kotlin
messageDisplay.setChristmasMode(true)
```

open 클래스는 서브클래스를 대신 제공할 수 있기 때문에 open 클래스를 활용하면 조금 더 자유를 얻을 수 있다. 

## 인터페이스

### 장점

- 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있다.
- 결합(coupling)을 줄일 수 있다.
- 코틀린은 멀티 플랫폼 언어로, 각 플랫폼에 최적화된 구현체를 사용하여 성능을 향상시킬 수 있다.
- 테스트할 때 인터페이스 Faking이 클래스 Mocking보다 간단하므로, 별도의 모킹 라이브러리를 사용하지 않아도 된다.
- 선언과 사용이 분리되어 있으므로, 실제 클래스를 자유롭게 변경할 수 있다.

### 단점

- 사용 방법을 변경하려면 해당 인터페이스를 구현하는 모든 클래스를 변경해야 한다.

## ID 만들기 (nextId)

### 어떤 정수 값을 계속 증가시키면서 이를 ID로 활용하기

```kotlin
var nextId: Int = 0

// 사용
val newId = nextId++
```

위 코드의 문제점

- ID가 생성되는 방식을 변경할 때 문제가 발생한다.
- 이 코드의 ID는 무조건 0부터 시작한다.
- 이 코드는 스레드-안전(thread-safe)하지 않다.

만약 이 방법을 사용해야 한다면, 이후에 발생할 수 있는 변경으로부터 코드를 보호할 수 있게 함수를 사용하는 것이 좋다.

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId++

// 사용
val newId = getNextId()
```

- ID 생성 방식의 변경으로부터는 보호된다.
- ID 타입 변경 등은 대응하지 못한다.

### 클래스 사용하기

```kotlin
data class Id(
    private val id: Int
)

private var nextId: Int = 0
fun getNextId(): Id = Id(nextId++)
```