---
description: 이펙티브 코틀린 정리하기
---

# 변화로부터 코드를 보호하려면 추상화를 사용하라

함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있다.

그리고 이후에 실질적인 코드를 원하는대로 수정할 수도 있다.

추상화의 균형을 맞추는 방법

- 상수
- 함수
- 클래스

## 상수

리터럴은 아무것도 설명하지 않는다. 따라서 코드에서 반복적으로 등장할 때 문제가 된다.

이러한 리터럴은 상수 프로퍼티로 변경하면 해당 값에 의미 있는 이름을 붙일 수 있으며, 상수의 값을 변경해야 할 때 쉽게 변경할 수 있다.

{% hint style="success" %}
두 번 이상 사용되는 값은 상수로 추출하는 것이 좋다.
{% endhint %}

### 장점

- 이름을 붙일 수 있다.
- 나중에 해당 값을 쉽게 변경할 수 있다.

## 함수

{% hint style="danger" %}
내부적으로만 사용하더라도, 함수의 이름을 직접 바꾸는 것은 위험할 수 있다. 
{% endhint %}

다른 모듈이 해당 함수에 의존하고 있다면, 다른 모듈에 큰 문제가 발생할 것이다.

컴파일러의 관점에서는 큰 차이가 없지만, 사람의 관점에서는 이름이 바뀌면 큰 변화가 일어난 것이다. 함수는 추상화를 표현하는 수단이며, 함수 시그니처는 해당 함수가 어떤 추상화를 표현하고 있는지를 알려준다. 따라서 의미 있는 이름은 굉장히 중요하다.

함수는 매우 단순한 추상화이지만, 제한이 많다.

- 함수는 상태를 유지하지 않는다.
- 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있다.

## 클래스

클래스는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다.

의존성 주입 프레임워크를 사용하면, 클래스 생성을 위임할 수도 있다.

```kotlin
@Inject lateinit var messageDisplay: MessageDisplay
```

또한 mock 객체를 활용해서 해당 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있다.

```kotlin
val messageDisplay: MessageDisplay = mockk()
```

더 다양한 종류의 메서드를 만들 수도 있다.

```kotlin
messageDisplay.setChristmasMode(true)
```

open 클래스는 서브클래스를 대신 제공할 수 있기 때문에 open 클래스를 활용하면 조금 더 자유를 얻을 수 있다. 