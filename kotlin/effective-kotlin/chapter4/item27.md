---
description: 이펙티브 코틀린 정리하기
---

# 변화로부터 코드를 보호하려면 추상화를 사용하라

함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있다.

그리고 이후에 실질적인 코드를 원하는대로 수정할 수도 있다.

추상화의 균형을 맞추는 방법

- 상수
- 함수
- 클래스

## 상수

리터럴은 아무것도 설명하지 않는다. 따라서 코드에서 반복적으로 등장할 때 문제가 된다.

이러한 리터럴은 상수 프로퍼티로 변경하면 해당 값에 의미 있는 이름을 붙일 수 있으며, 상수의 값을 변경해야 할 때 쉽게 변경할 수 있다.

{% hint style="success" %}
두 번 이상 사용되는 값은 상수로 추출하는 것이 좋다.
{% endhint %}

### 장점

- 이름을 붙일 수 있다.
- 나중에 해당 값을 쉽게 변경할 수 있다.

## 함수

{% hint style="danger" %}
내부적으로만 사용하더라도, 함수의 이름을 직접 바꾸는 것은 위험할 수 있다. 
{% endhint %}

다른 모듈이 해당 함수에 의존하고 있다면, 다른 모듈에 큰 문제가 발생할 것이다.

컴파일러의 관점에서는 큰 차이가 없지만, 사람의 관점에서는 이름이 바뀌면 큰 변화가 일어난 것이다. **함수는 추상화를 표현하는 수단이며, 함수 시그니처는 해당 함수가 어떤 추상화를 표현하고 있는지를 알려준다. 따라서 의미 있는 이름은 굉장히 중요하다.**

### 단점
- 함수는 상태를 유지하지 않는다.
- 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있다.

## 클래스

클래스는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다.

의존성 주입 프레임워크를 사용하면, 클래스 생성을 위임할 수도 있다.

```kotlin
@Inject lateinit var messageDisplay: MessageDisplay
```

또한 mock 객체를 활용해서 해당 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있다.

```kotlin
val messageDisplay: MessageDisplay = mockk()
```

더 다양한 종류의 메서드를 만들 수도 있다.

```kotlin
messageDisplay.setChristmasMode(true)
```

open 클래스는 서브클래스를 대신 제공할 수 있기 때문에 open 클래스를 활용하면 조금 더 자유를 얻을 수 있다. 

## 인터페이스

### 장점

- 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있다.
- 결합(coupling)을 줄일 수 있다.
- 코틀린은 멀티 플랫폼 언어로, 각 플랫폼에 최적화된 구현체를 사용하여 성능을 향상시킬 수 있다.
- 테스트할 때 인터페이스 Faking이 클래스 Mocking보다 간단하므로, 별도의 모킹 라이브러리를 사용하지 않아도 된다.
- 선언과 사용이 분리되어 있으므로, 실제 클래스를 자유롭게 변경할 수 있다.

### 단점

- 사용 방법을 변경하려면 해당 인터페이스를 구현하는 모든 클래스를 변경해야 한다.

## ID 만들기 (nextId)

### 어떤 정수 값을 계속 증가시키면서 이를 ID로 활용하기

```kotlin
var nextId: Int = 0

// 사용
val newId = nextId++
```

위 코드의 문제점

- ID가 생성되는 방식을 변경할 때 문제가 발생한다.
- 이 코드의 ID는 무조건 0부터 시작한다.
- 이 코드는 스레드-안전(thread-safe)하지 않다.

만약 이 방법을 사용해야 한다면, 이후에 발생할 수 있는 변경으로부터 코드를 보호할 수 있게 함수를 사용하는 것이 좋다.

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId++

// 사용
val newId = getNextId()
```

- ID 생성 방식의 변경으로부터는 보호된다.
- ID 타입 변경 등은 대응하지 못한다.

### 클래스 사용하기

```kotlin
data class Id(
    private val id: Int
)

private var nextId: Int = 0
fun getNextId(): Id = Id(nextId++)
```

## 추상화가 주는 자유

추상화를 하는 방법

- 상수로 추출하기
- 동작을 함수로 래핑하기
- 함수를 클래스로 래핑하기
- 인터페이스 뒤에 클래스를 숨기기
- 보편적인 객체를 특수한 객체로 래핑하기

추상화를 구현할 때 활용할 수 있는 도구

- 제네릭 타입 파라미터 사용하기
- 내부 클래스 추출하기
- 생성을 제한하기 (예 : 팩토리 함수로만 객체를 생성할 수 있게 하기)

## 추상화의 문제

{% hint style="danger" %}
추상화는 자유를 주지만 코드를 이해하고 수정하기 어렵게 만든다. 따라서 극단적으로 모든 것을 추상화해서는 안 된다.
{% endhint %}

추상화를 하려면 코드를 읽는 사람이 해당 개념을 배우고, 잘 이해해야 한다. 또 다른 방식으로 추상화를 하려면 또 해당 개념을 배우고 잘 이해해야 한다. 

추상화는 많은 것을 숨길 수 있는 테크닉이다. 생각할 것을 어느 정도 숨겨야 개발이 쉬워지는 것도 사실이지만 너무 많은 것을 숨기면 결과를 이해하는 것 자체가 어려워진다.

추상화를 이해하려면 예제를 살펴보는 것이 좋다. 단위 테스트와 문서의 예제는 추상화가 어떻게 사용되는지 보여준다. 

## 어떻게 균형을 맞춰야 할까?

프로젝트에 따라서 균형이 다를 수 있다.

- 팀의 크기
- 팀의 경험
- 프로젝트의 크기
- 특징 세트(feature set)
- 도메인 지식

규칙

- 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어렵다. 따라서 추상화 방법을 사용하는 것이 좋다. 최대한 추상화 방법을 사용하는 것이 좋다. 최대한 모듈과 부분(part)를 분리하는 것이 좋다.
- 의존성 주입 프레임워크를 사용하면, 생성이 얼마나 복잡한지는 신경 쓰지 않아도 된다.
- 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는 것이 좋다.
- 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮다. 문제가 발생했다면 최대한 빨리 직접 변경하면 된다.

{% hint style="success" %}
항상 무언가 변화할 수 있다고 생각하는 것이 좋다.
{% endhint %}

## 정리

추상화는 단순하게 중복성을 제거해서 코드를 구성하기 위한 것이 아니다.

추상화는 코드를 변경해야 할 때 도움이 된다. 따라서 추상화를 사용하는 것은 굉장히 어렵지만, 이를 배우고 이해해야 한다.

다만 추상적인 구조를 사용하면, 결과를 이해하기 어렵다. 추상화를 사용할 때의 장점과 단점을 모두 이해하고, 프로젝트 내에서 그 균형을 찾아야 한다. 추상화가 너무 많거나 너무 적은 상황 모두 좋은 상황이 아니다.