---
description: 이펙티브 코틀린 정리하기
---

# 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라

메모리 관리를 완전히 무시해 버리면, 메모리 누수가 발생해서 상황에 따라 OutOfMemoryError가 발생하기도 한다. 따라서 '더 이상 사용하지 않는 객체의 레퍼런스를 유지하면 안된다.'라는 규칙은 지켜 주는 것이 좋다. 특히, 어떤 객체가 메모리를 많이 차지하거나, 어떤 객체의 인스턴스가 많이 생성될 경우에는 규칙을 꼭 지켜줘야 한다.

객체에 대한 참조를 companion(또는 static)으로 유지해 버리면, 가비지 컬렉터가 해당 객체에 대한 메모리 해제를 할 수 없다.

이를 개선할 수 있는 방법은 일단 이러한 리소스를 정적으로 유지하지 않는 것이 가장 좋다. 의존 관계를 정적으로 저장하지 말고, 다른 방법을 활용해서 적절하게 관리하는 것이 좋다. 또한, 객체에 대한 레퍼런스를 다른 곳에 저장할 때는 메모리 누수가 발생할 가능성을 언제나 염두에 둬야 한다.

```kotlin
class MainActivity: Activity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // ...

        // this에 대한 레퍼런스 누수가 발생한다.
        logError = { Log.e(this::class.simpleName, it.message) }
    }

    // ...

    companion object {
        // 이렇게 하지 마세요. 메모리 누수가 발생한다.
        var logError: ((Throwable) -> Unit)? = null
    }

}
```

거의 사용되지 않는 객체까지 이런 것을 신경 쓰는 것은 오히려 좋지 않을 수도 있다. 하지만 오브젝트에 null을 설정하는 것은 그렇게 어려운 일이 아니므로, 무조건 하는 것이 좋다. 특히, 많은 변수를 캡처할 수 있는 함수 타입, Any 또는 제네릭 타입과 같은 미지의 클래스일 때는 이러한 처리가 중요하다.

일반적인 규칙은 상태를 유지할 때는 메모리 관리를 염두에 두어야 한다는 것이다. 코드를 작성할 때는 '메모리와 성능' 뿐만 아니라 '가독성과 확장성'을 항상 고려해야 한다. 일반적으로 가독성이 좋은 코드는 메모리와 성능적으로도 좋다. 가독성이 좋지 않은 코드는 메모리와 CPU 리소스의 낭비를 숨기고 있을 가능성이 높다.

물론 둘 사이에 트레이드 오프가 발생하는 경우도 있다. 이럴 때는 일반적으로 가독성과 확장성을 더 중시하는 것이 좋다. 예외적으로 라이브러리를 구현할 때는 메모리와 성능이 더 중요하다.

일반적으로 절대 사용되지 않는 객체를 캐시해서 저장해 두는 경우 메모리 누수가 발생한다. 물론 캐시를 해두는 것이 나쁜 것은 아니다. 하지만 이것이 OutOfMemoryError를 일으킬 수 있다면, 아무런 도움이 되지 않는다.

해결 방법은 소프트 레퍼런스를 사용하는 것이다. 소프트 레퍼런스를 활용하면, 메모리가 필요한 경우네는 가비지 컬렉터가 이를 알아서 해제한다. 하지만 메모리가 부족하지 않아서 해제되지 않았다면, 이를 활용할 수 있다.

메모리 누수는 예측하기 어렵다. 애플리케이션이 크래시되기 전까지 있는지 확인하기 힘들 수도 있다. 그래서 별도의 도구들을 활용해서 메모리 누수를 찾는 것도 좋은 방법이다. 가장 기본적인 도구로는 힙 프로퍼일러가 있다. 또한 메모리 누수 탐색에 도움이 되는 라이브러리도 있다. 안드로이드에서 메모리 누수가 검출될 때마다 알려주는 LeakCanary가 있다.

사실 객체를 수동으로 해제해야 하는 경우는 굉장히 드물다. 일반적으로 스코프를 벗어나면서, 어떤 객체를 가리키는 레퍼런스가 제거될 때, 객체가 자동으로 해제된다. 

{% hint style="success" %}
메모리와 관련된 문제를 피하는 가장 좋은 방법은 변수를 지역 스코프에 정의하고, 톱레벨 프로퍼티 또는 객체 선언으로 큰 데이터를 저장하지 않는 것이다.
{% endhint %}