---
description: Real MySQL 8.0
---

# 3. 복제 타입

## 1. 바이너리 로그 파일 위치 기반 복제

- MySQL에 복제 기능이 처음 도입됐을 때부터 제공된 방식
- 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset 또는 Position)로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태
- 소스 서버에서 발생한 각 이벤트에 대한 식별이 반드시 필요하다. 
    - 레플리카 서버에 소스 서버의 어떤 이벤트부터 동기화를 수행할 것인가에 대한 정보
    - 레플리카 서버는 소스 서버의 어느 이벤트까지 로컬 디스크로 가져왔고 또 적용했는지에 대한 정보
- 복제에 참여한 MySQL 서버들이 모두 고유한 server_id 값을 가지고 있어야 한다. (동일한 server_id 값을 가지는 경우 자신의 서버에서 발생한 이벤트로 간주해서 적용 X)

### (1) 바이너리 로그 파일 위치 기반의 복제 구축

#### 1. 설정 준비

- 바이너리 로그 활성화 필요
- 복제 구성원이 되는 각 MySQL 서버가 고유한 server_id 값을 가져야 한다.
- 소스 서버에서 바이너리 로그가 정상적으로 기록되고 있는지는 `SHOW MASTER STATUS` 명령으로 확인할 수 있다.
- 레플리카 서버는 일반적으로 읽기 전용으로 사용되므로 read_only 설정도 함께 사용하는 편이 좋다.
- 추후 소스 서버의 장애로 레플리카 서버가 소스 서버로 승격될 수 있음을 고려하면, log_slave_updates 시스템 변수도 명시하는 것이 좋다. (복제에 의한 데이터 변경 내용도 자신의 바이너리 로그에 기록하게 된다.)

#### 2. 복제 계정 준비

- 레플리카 서버가 소스 서버로 부터 바이너리 로그를 가져오기 위해서 소스 서버에 접속해야 함으로 접속 시 사용할 DB 계정 필요. 이때 레플리카 서버가 사용할 계정을 **복제용 계정**이라고 한다.
- 복제에서 사용되는 계정의 비밀번호는 레플리카 서버의 커넥션 메타데이터에 평문으로 저장됨. → 보안 측면을 고려해서 복제에 사용되는 권한만 주어진 별도의 계정을 생성하여 사용하는 것이 좋다.
- REPLICATION SLAVE 권한 필요

#### 3. 데이터 복사

소스 서버의 데이터를 레플리카 서버로 가져와서 적재할 때, MySQL 엔터프라이즈 백업이나 mysqldump 등과 같은 툴을 이용해서 복사할 수 있다.

일반적으로 데이터가 크지 않다면 mysqldump를 많이 사용한다.

mysqldump 사용해 소스 서버의 데이터를 덤프할 때는 `--single-transaction`과 `--master-data`라는 두 옵션을 반드시 사용해야 한다.
- `--single-transaction`
    - 데이터를 덤프할 때 하나의 트랜잭션을 사용해 덤프가 진행되게 해서 mysqldump가 테이블이나 레코드에 잠금을 걸지 않고 InnoDB 테이블들에 대해 일관된 데이터를 덤프받을 수 있게 한다.
- `--master-data`
    - 덤프 시작 시점의 소스 서버의 바이너리 로그 파일명과 위치 정보를 포함하는 복제 설정 구문이 덤프 파일 헤더에 기록될 수 있게 하는 옵션
    - 글로벌 락을 걸어 바이너리 로그의 위치를 순간적으로 고정시키기 위함.

데이터 덤프가 완료되면 source_data.sql 파일을 레플리카 서버로 옮겨 데이터 적재를 진행한다.


#### 4. 복제 시작

복제를 설정하는 명령은 `CHANGE REPLICATION SOURCE TO` 또는 `CHANGE MASTER TO` 명령으로 mysqldump로 백업 받는 파일의 헤더 부분에서 해당 명령어를 참조할 수 있다.

복제 설정에 보안된 연결(SSL)과 관련된 옵션들을 명시하지 않아 레플리카 서버가 소스 서버와 암호화되지 않는 통신 방식으로 연결된 경우, 'GET_SOURCE_PUBLIC_KEY=1' 구문 없이 복제 설정 후 복제를 시작했을 때 에러가 발생할 수 있으므로 반드시 설정해야 한다.

`START REPLICA` 또는 `START SLAVE` 명령을 실행하면 동기화가 시작된다. 데이터를 덤프한 뒤 해당 명령을 실행하기까지 변경된 데이터가 많다면 생각보다 시간이 걸릴 수 있다. 

### (2) 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기

복제로 구성돼 있는 MySQL 서버들이 운영하다 보면 종종 레플리카 서버에서 소스 서버로부터 넘어 온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 현상이 발생하기도 한다.

경우에 따라 레플리카 서버에서 문제되는 소스 서버의 트랜잭션을 무시하고 넘어가도록 처리해도 괜찮을 때는 `sql_slave_skip_counter` 시스템 변수를 이용해 문제되는 트랜잭션을 건너뛸 수 있다.

- 1로 설정되면 MySQL 서버에서는 실제로 DML 쿼리 문장 하나를 가진 바이너리 로그 이벤트 1개를 무시하는 것이 아니라 현재 이벤트를 포함한 이벤트 그룹을 무시한다. (트랜잭션을 지원하는 테이블의 경우, 트랜잭션이 하나의 이벤트 그룹이 된다.)

하나의 트랜잭션에 여러 개의 DML 쿼리들이 포함되는 경우가 존재한다면 에러가 발생한 쿼리 외에 다른 쿼리들이 예상치 못하게 함께 무시될 수 있기 때문에 주의해서 사용해야 한다.

## 2. 글로벌 트랜잭션 아이디(GTID) 기반 복제
