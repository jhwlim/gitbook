---
description: Real MySQL 8.0
---

# 9. 유니크 인덱스

유니크는 사실 인덱스라기 보다는 제약 조건에 가까운데, 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없을 의미한다.

MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다. MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여된다.

InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하므로, 유니크 인덱스와는 근본적으로 다르다. (MyISAM이나 MEMORY 테이블에서 프라이머리 키는 사실 NULL이 허용되지 않는 유니크 인덱스와 동일하다.)

## 1. 유니크 인덱스와 일반 세컨더리 인덱스의 비교

유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없다.

### (1) 인덱스 읽기

유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼값을 비교하는 작업이다. (성능상 거의 영향이 없음.) 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야할 레코드가 많아서 느린 것이다.

만약 **읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.**

### (2) 인덱스 쓰기

유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. → 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.

그런데 MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데, 이 과정에서 데드락이 아주 빈번히 발생한다.

또한, InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼(Change Buffer)가 사용된다. 그래서 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못한다.

**이 때문에 유니크 인덱스는 일반 세컨더리 인덱스본다 변경 작업이 더 느리게 작동한다.**

## 2. 유니크 인덱스 사용 시 주의사항

- 꼭 필요한 경우라면 유니크 인덱스를 생성하는 것은 당연한다. 하지만 더 성능이 좋아질 것으로 생각하고 불필요하게 우니크 인덱스를 생성하지 않는 것이 좋다.
- MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요는 없다.
- 똑같은 칼럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 생성한 경우도 있는데, 이 또한 불필요한 중복이다.
- 유니크 인덱스는 쿼리의 실행 계획이나 테이블의 파티션에 미치는 영향이 있음. (10장 실행계획, 13장 파티션 참고)

{% hint style="success" %}

유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 한 번씩 고려해보자.

{% endhint %}




