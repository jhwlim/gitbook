---
description: Real MySQL 8.0
---

# 4. SELECT

웹 서비스 같이 일반적인 온라인 트랜잭션 처리 환경의 데이터베이스에서는 INSERT나 UPDATE 같은 작업은 거의 레코드 단위로 발생하므로 성능상 문제가 되는 경우는 별로 없다. 

하지만 SELECT는 여러 개의 테이블로부터 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을 어떻게 읽을 것인가에 많은 주의를 기울여야 한다. 하나의 애플리케이션에서 사용되는 쿼리 중에서도 SELECT 쿼리의 비율은 높다.

## 1. SELECT 절의 처리 순서

각 쿼리 절의 실행순서

- WHERE 적용 및 조인 실행 → GROUP BY → DISTINCT → HAVING 조건 적용 → ORDER BY → LIMIT
- ORDER BY 나 GROUP BY 절이 있더라도 인덱스를 이용해 처리할 때는 그 단계 자체가 불필요하므로 생략된다.

예외적으로 ORDER BY가 조인보다 먼저 실행되는 경우

- WHERE 적용 → ORDER BY → 조인 실행 → LIMIT
- 첫 번째 테이블만 읽어서 정렬을 수행한 뒤에 나머지 테이블을 읽는다.
- 주로 GROUP BY 절이 없이 ORDER BY만 사용된 쿼리에서 사용될 수 있는 순서다.

위에서 소개한 실행 순서를 벗어나는 쿼리가 필요하다면 서브쿼리로 작성된 **인라인 뷰**를 사용해야 한다.

- 예 : LIMIT를 먼저 적용하고 ORDER BY를 실행 (p54 참고)

하지만 인라인 뷰가 사용되면 임시 테이블이 사용되기 때문에 주의해야 한다.

WITH절(CTE, Common Table Expression)은 항상 제일 먼저 실행되어 임시 테이블로 저장된다. 그리고 WITH 절로 만들어진 임시 테이블은 단독으로 조회되거나 조인되는 테이블로 활용된다.

## 2. WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용

### (1) 인덱스를 사용하기 위한 기본 규칙

WHERE 절이나 ORDER BY 또는 GROUP BY가 인덱스를 사용하려면 기본적으로 인덱스된 칼럼 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다.

복잡한 연산을 수행한다거나 MD5() 함수와 같이 해시 값을 만들어서 비교해야 하는 경우라면 미리 계산된 값을 저장하도록 MySQL의 가상 칼럼을 추가하고, 그 칼럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용하면 된다.

결론적으로 인덱스의 칼럼을 변형해서 비교하는 경우에는 인덱스를 이용할 수 없게 된다는 점에 주의해야 한다.

추가로 WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다.

비교되는 두 값의 타입이 다를 때, MySQL 옵티마이저가 내부적으로 문자열 타입을 숫자 타입으로 변환한 후 비교 작업을 처리한다.

저장하고자 하는 값의 타입에 맞춰 칼럼을 선정하고, SQL을 작성할 때는 데이터의 타입에 맞춰서 비교 조건을 사용하길 권장한다.

### (2) WHERE 절의 인덱스 사용

WHERE 조건이 인덱스를 사용하는 방법은 크게 **작업 범위 결정 조건**과 **체크 조건**의 두 가지 방식으로 구분할 수 있다. 두 방식 중 작업 범위 결정 조건은 WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서부터 비교했을 때, 얼마나 일치하는가에 따라 달라진다.

WHERE 조건절에 나열된 순서가 인덱스와 다르더라도 MySQL 서버 옵티마이저는 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화를 수행할 수 있다.

GROUP BY나 ORDER BY와는 달리 WHERE 절의 조건절은 순서를 변경해도 결과의 차이가 없기 때문에, WHERE 절에서의 각 조건이 명시된 순서는 중요치 않고 인덱스를 구성하는 칼럼에 대한 조건이 있는지 없는지가 중요하다.

각 조건이 OR로 연결되면 읽어서 비교해야 할 레코드가 더 늘어나기 때문에 WHERE 조건에 OR 연산자가 있다면 주의해야 한다.

### (3) GROUP BY 절의 인덱스 사용

GROUP BY 절의 각 칼럼은 비교 연산자를 가지지 않으므로 작업 범위 결정 조건이나 체크 조건과 같이 구분해서 생각할 필요는 없다. GROUP BY 절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면 GROUP BY 절은 일단 인덱스를 이용할 수 있다.

**GROUP BY 절의 인덱스 사용 규칙**

- GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야 한다.
- 인덱스를 구성하는 칼럼 중에서 뒤쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만, 인덱스의 앞쪽에 있는 칼럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
- WHERE 조건절과 달리 GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다.

### (4) ORDER BY 절의 인덱스 사용

ORDER BY 절의 인덱스 사용 여부는 GROUP BY의 요건과 거의 흡사하지만, ORDER BY는 조건이 하나 더 있다. 정렬되는 각 칼럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다.

인덱스의 모든 칼럼이 ORDER BY 절에 사용돼야 하는 것은 아니지만, ORDER BY 절의 칼럼들이 인덱스에 정의된 칼럼의 왼쪽부터 일치해야 한다.

### (5) WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용

SQL 문장이 WHERE 절과 ORDER BY 절을 가지고 있다고 가정할 때, WHERE 조건은 A 인덱스를 사용하고, ORDER BY 는 B 인덱스를 사용하도록 쿼리가 실행될 수는 없다. 이는 WHERE 절과 GROUP BY 절이 같이 사용된 경우와 GROUP BY와 ORDER BY가 같이 사용된 쿼리에서도 마찬가지다.

- WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용 : 훨씬 빠른 성능을 보이기 때문에 가능하다면 이 방식으로 처리할 수 있게 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.
- WHERE 절만 인덱스를 이용 : 주로 WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을 때 효율적인 방식
- ORDER BY 절만 인덱스를 이용 : 주로 아주 많은 레코드를 조회해서 정렬해야 할 때 이런 형태로 튜닝하기도 한다.

또한 WHERE 절에서 동등 비교 조건으로 비교된 칼럼과 ORDER BY 절에 명시된 칼럼이 순서대로 빠짐없이 인덱스 칼럼의 왼쪽부터 일치해야 한다.

하지만 중간에 빠지는 칼럼이 있으면, WHERE 절이나 ORDER BY 절 모두 인덱스를 사용할 수 없다. 이때는 주로 WHERE 절만 인덱스를 이용할 수 있다.

ORDER BY 절에 해당 칼럼이 사용되고 있다면 WHERE 절에 동등 비교 이외의 연산자로 비교돼도 WHERE 조건과 ORDER BY 조건이 모두 인덱스를 할 수 있다. 일반적으로 WHERE 절에서 동등 비교로 사용된 칼럼과 ORDER BY 절의 칼럼이 인덱스를 구성하는 칼럼과 같은 순서로 연속해서 사용됐는지를 확인해야 한다.

예시 : COL_1, COL_2, COL_3  인덱스

```sql
-- 인덱스 사용 가능
SELECT * FROM tb_test WHERE COL_1 = 10 ORDER BY COL_2, COL_3; // 동등 조건
SELECT * FROM tb_test WHERE COL_1 > 10 ORDER BY COL_1, COL_2, COL_3; // 범위 조건

-- 인덱스 사용 불가
SELECT * FROM tb_test WHERE COL_1 > 10 ORDER BY COL_2, COL_3; // 범위 조건
```

WHERE 절과 ORDER BY나 GROUP BY 절의 조합에서 인덱스의 사용 여부를 판단하는 능력은 상당히 중요하므로 여러 가지 경우에 대해 직접 테스트해보는 것이 좋다.

### (6) GROUP BY 절과 ORDER BY 절의 인덱스 사용

GROUP BY와 ORDER BY 절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 GROUP BY 절에 명시된 칼럼과 ORDER BY에 명시된 칼럼의 순서와 내용이 모두 같아야 한다.

GROUP BY와 ORDER BY가 같이 사용된 쿼리에서는 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못한다. 즉, GROUP BY는 인덱스를 이용할 수 있지만 ORDER BY가 인덱스를 이용할 수 없을 때, 이 쿼리의 GROUP BY와 ORDER BY 절은 모두 인덱스를 이용하지 못한다. 그 반대의 경우도 마찬가지다.

### (7) WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용

WHERE 절과 GROUP BY 절, ORDER BY 절이 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법

1. WHERE 절이 인덱스를 사용할 수 있는가?
2. GROUP BY 절이 인덱스를 사용할 수 있는가?
3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?

## 3. WHERE 절의 비교 조건 사용 시 주의사항

쿼리가 최적으로 실행되려면 적합한 인덱스와 함께 WHERE 절에 사용되는 비교 조건의 표현식을 적절하게 사용해야 한다.

### (1) NULL 비교

MySQL에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다. 이는 인덱스에서는 NULL을 하나의 값으로 인정해서 관리한다는 것을 의미한다.

SQL 표준에서는 NULL의 저의는 비교할 수 없는 값이다. 그래서 두 값이 모두 NULL을 가진다고 하더라도 이 두 값이 동등한지 비교하는 것은 불가능하다. 연산이나 비교에서 한쪽이라도 NULL이면 그 결과도 NULL이 반환되는 이유가 바로 이 때문이다. 

쿼리에서 NULL인지 비교하려면 `IS NULL` (또는 `<=>`) 연산자를 사용해야 한다.

칼럼의 값이 NULL인지 확인할 때는 `ISNULL()` 이라는 함수를 사용해도 된다. 하지만 `ISNULL()` 함수를 WHERE 조건에서 사용할 때는 주의할 점이 있다.

```sql
-- 인덱스 사용 가능 : 인덱스 레인지 스캔
SELECT * FROM titles WHERE to_date IS NULL; 
SELECT * FROM titles WHERE ISNULL(to_date); 

-- 인덱스 사용 불가 : 인덱스 풀 스캔 또는 테이블 풀 스캔
SELECT * FROM titles WHERE ISNULL(to_date)=1;
SELECT * FROM titles WHERE ISNULL(to_date)=true;
```

NULL을 비교할 때는 가급적 `IS NULL` 연산자를 사용하길 권장한다.

### (2) 문자열이나 숫자 비교

문자열 칼럼이나 숫자 칼럼을 비교할 때는 반드시 그 타입에 맞는 상수값을 사용할 것을 권장한다.

칼럼의 타입에 맞게 상수 리터럴을 비교 조건에 사용하는 것이 중요하다.

### (3) 날짜 비교

1. DATE 또는 DATETIME과 문자열 비교
    - DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다.
    - 칼럼의 타입이 DATE나 DATETIME 타입이면 별도로 문자열을 DATE나 DATETIME 타입으로 명시적으로 변환하지 않아도 MySQL 내부적으로 변환을 수행한다.
    - 칼럼의 타입을 강제적으로 문자열로 변경하면 인덱스를 효율적으로 사용하지 못하므로, 가능하면 DATE나 DATETIME 타입의 칼럼은 변경하지 말고 상수를 변경하는 형태로 조건을 사용하는 것이 좋다.
2. DATE와 DATETIME의 비교
    - DATETIME 값에서 시간 부분만 떼어버리고 비교하려면 DATE() 함수를 사용하면 된다. DATE() 함수는 DATETIME 타입의 값에서 시간 부분은 버리고 날짜부분만 반환하는 함수다.
    - DATETIME 타입의 값을 DATE 타입으로 만들지 않고, 그냥 비교하면 MySQL 서버가 DATE 타입의 값을 DATETIME으로 변환해서 같은 타입으로 만든 다음 비교를 수행한다.
    - DATETIME과 DATE 타입의 비교에서 타입 변환은 인덱스의 사용 여부에 영향을 미치지 않기 때문에, 성능보다는 쿼리의 결과에주의해서 사용하면 된다.
3. DATETIME과 TIMESTAMP의 비교
    - DATE나 DATETIME 타입의 값과 TIMESTAMP의 값을 별도의 타입 변환 없이 비교하면 문제없이 작동하고 실제 실행 계획도 인덱스 레인지 스캔을 사용해서 동작하는 것처럼 보이지만 사실은 그렇지 않다.
    - 칼럼이 DATETIME 타입이라면 FROM_UNIXTIME() 함수를 이용해 TIMESTAMP 값을 DATETIME 타입으로 만들어서 비교해야 한다.
    - 칼럼의 타입이 TIMESTAMP라면 UNIX_TIMESTAMP() 함수를 이용해 DATETIME을 TIMESTAMP로 변환해서 비교해야 한다.

### (4) Short-Circuit Evaluation

여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우, 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화

MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 ‘Short-Circuit Evaluation’ 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정한다.

그런데 WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 ‘Short-Circuit Evaluation’과는 무관하게 MySQL 서버는 그 조건을 가장 최우선으로 사용한다. 그래서 WHERE 조건절에 나열된 조건의 순서가 인덱스의 사용 여부를 결정하지는 않는다.

MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것이다.

물론 WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 된다.

## 4. DISTINCT

DISTINCT를 남용하는 것은 성능적인 문제도 있지만 쿼리의 결과도 의도한 바와 달라질 수 있다. 

(9.2.5. DISTINCT 처리 참고)

각 테이블 간의 업무적인 연결 조건을 이해하지 못하고 쿼리를 작성하는 경우, DISTINCT를 남용하는 경우가 발생할 수 있다. 테이블 간 조인 쿼리르 작성하는 경우 각 테이블 간의 조인이 1:1 조인인지 1:M 조인인지 업무적인 특성을 잘 이해 하는 것이 중요하다.

## 5. LIMIT n

LIMIT은 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용한다.

MySQL의 LIMIT은 WHERE 조건이 아니기 때문에 항상 쿼리의 가장 마지막에 실행된다.

LIMIT의 중요한 특성은 LIMIT에서 필요한 레코드 건수만 준비되면 즉시 쿼리르 종료한다는 것이다. 즉, 모든 레코드의 정렬이 완료되지 않았다고하더라도 상위 n개가 정렬되면 작업을 멈춘다.

- 정렬이나 그루핑 또는 DISTINCT가 없는 쿼리에서 LIMIT 조건을 사용하면 쿼리가 상당히 빨리 끝날 수 있다.
- LIMIT이 GROUP BY와 함께 사용되는 경우에는 LIMIT 절이 있더라도 실질적인 서버의 작업 내용을 크게 줄여주지는 못한다.
- DISTINCT와 함께 사용된 LIMIT은 실질적인 중복 제거 작업의 범위를 줄이는 역할을 한다. LIMIT 절이 작업량을 상당히 줄여줄 수 있다.
- 정렬을 수행하면서 필요한 n건이 완성되는 순간, 나머지 작업을 멈추고 결과를 사용자에게 반환한다. (필뇨한 만큼만 정렬되면 된다.) 하지만 크게 작업량을 줄여주지는 못한다.

쿼리 문장에 GROUP BY나 ORDER BY 같은 전체 범위 작업이 선행되더라도 LIMIT 절이 있다면 크지는 않지만 나름의 성능 향상은 있다고 볼 수 있다.

ORDER BY나 GROUP BY 또는 DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어주기 때문에 쿼리의 작업량을 상당히 줄여준다.

LIMIT의 제한사항으로는 LIMIT의 인자로 표현식이나 별도의 서브쿼리를 사용할 수 없다는 것이 있다.

LIMIT는 실제 쿼리의 성능은 사용자의 화면에 레코드가 몇 건 출력되는냐보다는 MySQL 서버가 그 결과를 만들어 내기 위해 어떠한 작업들을 했는지가 중요하다.

`LIMIT n, m` 에서 n과 m에 주어지는 수치가 매우 커질 수 있는데, 이런 경우에는 쿼리 실행에 상당히 오랜 시간 걸린다.

LIMIT 조건의 페이징이 처음 몇 개 페이지 조회로 끝나지 않을 가능성이 높다면, WHERE 조건절로 읽어야 할 위치를 찾고 그 위치에서 특정 개수만 읽는 형태의 쿼리를 사용하는 것이 좋다.

이때, 중복이나 누락이 발생할 수 있기 때문에, 조건으로 사용하는 칼럼이 유니크한지 주의해야 한다.

## 6. COUNT()

COUNT() 함수는 칼럼이나 표현식을 인자로 받으며, 특별한 형태로 `*` 를 사용할 수 있다. 여기서 `*` 는 SELECT 절에 사용될 때 처럼 모든 칼럼을 가져오라는 의미가 아니라 그냥 레코드 자체를 의미하는 것이다. 실제로 COUNT(*)라고 해서 레코드의 모든 칼럼을 읽는 형태로 처리하지 않는다. 그래서 COUNT(프라이머리 키) 또는 COUNT(1)과 같이 사용하지 않고, COUNT(*)라고 표현해도 동일한 처리 성능을 보인다.

MYISAM 스토리지 엔진을 사용하는 테이블은 항상 테이블의 메타 정보에 전체 레코드 건수를 관리한다. 그래서 WHERE 조건이 없는 COUNT(*) 쿼리는 빠르게 처리된다. 하지만 WHERE 조건이 있는 COUNT(*) 쿼리는 그 조건에 일치하는 레코드를 읽어 보지 않는 이상 알 수 없으므로, 일반적인 DBMS와 같이 처리된다.

InnoDB 스토리지 엔진을 사용하는 테이블에서는 WHERE 조건이 없는 COUNT(*) 쿼리라고 하더라도 직접 데이터나 인덱스를 읽어야만 레코드 건수를 가져올 수 있기 때문에 큰 테이블에서 COUNT() 함수를 사용하는 작업은 주의해야 한다.

테이블이 가진 대략적인 레코드 건수로 충분하다면 SELECT COUNT(*) 보다는 SHOW TABLE STATUS 명령으로 통계 정보를 참조하는 것도 좋은 방법이다. 통계 정보와 실제 레코드 건수와 차이가 있을 수 있는데, 이런 경우에는 ANALYZE TABLE 명령을 실행해 통계 정보를 갱신하면 된다.

COUNT(*) 쿼리에서 ORDER BY 절은 어떤 경우에도 필요치 않다. 그리고 LEFT JOIN 또한 레코드 건수의 변화가 없거나 아우터 테이블에서 별도의 체크를 하지 않아도 되는 경우에는 모두 제거하는 것이 성능상 좋다.

MySQL 8.0 버전부터는 SELECT COUNT(*) 쿼리에 사용된 ORDER BY 절은 옵티마이저가 무시하도록 개선됐다. 하지만 꼭 필요한 부분만 간결하게 사용해 쿼리를 작성하는 것은 쿼리의 복잡도를 낮추고 가독성을 높인다는 장점이 있다.

인덱스를 제대로 사용하도록 튜닝되지 못한 COUNT(*) 쿼리는 페이징해서 데이터를 가져오는 쿼리보다 몇 배 또는 몇십 배 더 느리게 실행될 수 있다. COUNT(*) 쿼리도 많은 부하를 일으키기 때문에 주의 깊게 작성해야 한다.

COUNT() 함수에 칼럼명이나 표현식이 인자로 사용되면 그 칼럼이나 표현식의 결과가 NULL이 아닌 레코드 건수만 반환한다. 그래서 NULL이 될 수 있는 칼럼을 COUNT() 함수에 사용할 때는 의도대로 쿼리가 작동하는지 확인하는 것이 좋다.

페이징할 때 전체 건수를 조회하는 작업은 피하는 것이 좋은데, 페이지 번호를 보여주는 방식보다는 이전, 다음 버튼만 표시하는 방식을 검토해볼 것을 권장한다.

## 7. JOIN

### (1) JOIN의 순서와 인덱스

인덱스 레이지 스캔은 인덱스를 탐색하는 단계와 인덱스를 스캔하는 과정으로 구분할 수 있다.

일반적으로 인덱스를 이용해서 쿼리하는 작업에서는 가져오는 레코드 건수가 소량이기 때문에, 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높은 편이다.

조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 된다.

하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽는 레코드 건수만큼 반복한다. 드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다. 그래서 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.

### (2) JOIN 칼럼의 데이터 타입

조인 칼럼 간의 비교에서 각 칼럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 이용할 수 없다.

인덱스 사용에 영향을 미치는 데이터 타입 불일치는 CHAR 타입과 VARCHAR 타입, 또는 INT 타입과 BIGINT 타입, 그리고 DATE 타입과 DATETIME 타입 사이에서는 발생하지 않는다.

문제가 될 가능성이 높은 비교 패턴

- CHAR 타입과 INT 타입의 비교와 같이 데이터 타입의 종류가 완전히 다른 경우
- 같은 CHAR 타입이더라도 문자 집합이나 콜레이션이 다른 경우 (utf8mb4_general_ci, latin1_general_ci)
- 같은 INT 타입이더라도 부호의 존재 여부가 다른 경우

### (3) OUTER JOIN의 성능과 주의사항

테이블의 데이터가 일관되지 않은 경우에만 아우터 조인이 필요한 경우이다.

필요한 데이터와 조인되는 테이블 간의 관계를 정확히 파악해서 꼭 필요한 경우가 아니라면 이너 조인을 사용하는 것이 업무 요건을 정확히 구현함과 동시에 쿼리의 성능도 향상 시킬 수 있다.

아우터 조인 쿼리를 작성하면서 많이 하는 또 다른 실수는 아우터로 조인되는 테이블에 대한 조건을 WHERE 절에 함께 명시하는 것이다.

```sql
SELECT *
FROM employees e
	LEFT JOIN dept_manager mgr ON mgr.emp_no = e.emp_no
WHERE mgr.dept_no = 'd0001';
```

- 아우터로 조인되는 테이블인 dept_manage의 dept_no = ‘d001’ 조건을 WHERE 절에 명시한 것은 잘못된 조인 방법이다.

정상적인 아우터 조인이 되게 만들려면 WHERE 절의 ‘mgr.dept_no = ‘d001’ 조건을 LEFT JOIN의 ON 절로 옮겨야 한다.

```sql
SELECT *
FROM employees e
	LEFT JOIN dept_manage mgr 
	ON mgr.emp_no = e.emp_no AND mgr.dept_no = 'd001';
```

예외적으로 OUTER JOIN으로 연결되는 테이블의 칼럼에 대한 조건을 WHERE 절에 사용해야 하는 경우가 있는데, 다음과 같이 안티 조인 효과를 기대하는 경우가 그렇다.

```sql
SELECT *
FROM employees e
	LEFT JOIN dept_manage dm ON dm.emp_no e.emp_no
WHERE dm.emp_no IS NULL
LIMIT 10;
```

- WHERE 절에 아우터로 조인된 dept_manage 테이블의 emp_no 칼럼이 NULL인 레코드들만 조회한다.

이런 형태의 요건이 아우터 테이블의 칼럼이 WHERE 절에 사용될 수 있는 유일한 경우다. 

그 외의 경우 MySQL 서버는 LEFT JOIN을 INNER JOIN으로 자동 변환한다.

### (4) JOIN과 외래키(FOREIGN KEY)

외래키는 조인과 아무런 연관이 없다. SQL로 테이블 간의 조인을 수행하는 것은 전혀 무관한 칼럼을 조인 조건으로 사용해도 문법적으로는 문제가 되지 않는다.

### (5) 지연된 조인 (Delayed JOIN)

조인을 사용해서 데이터를 조회하는 쿼리에 GROUP BY 또는 ORDER BY를 사용할 때 각 처리 방법에서 인덱스를 사용한다면 이미 최적으로 처리되고 있을 가능성이 높다. 하지만 그렇지 못하다면 MySQL 서버는 우선 모든 조인을 실행하고 난 다음 GROUP BY나 ORDER BY를 처리할 것이다.

**지연된 조인**이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미한다. 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있다.

물론 지연된 조인으로 개선된 쿼리는 임시 테이블을 한 번 더사용하기 때문에 느리다고 예상할 수 있지만, 임시 테이블에 저장할 레코드가 작기 때문에 메모리를 이용해 빠르게 처리된다. 실제 테스트를 해보면 지연된 조인으로 개선된 쿼리가 3~4배 정도는 더 빠르게 실행된다는 것을 확인할 수 있다.

지연된 조인은 경우에 따라 상당한 성능 향상을 가져올 수 있지만 모든 쿼리를 지연된 조인 형태로 개선할 수 있는 것은 아니다.

- LEFT (OUTER) JOIN 인 경우 : 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야 한다.
- INNER JOIN 인 경우 : 드라이빙 테이블과 드리븐 테이블이 1:1 또는 M:1 곤계임과 동시에 드라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야 한다.

지연된 조인은 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 한다.

### (6) 래터럴 조인 (Lateral JOIN)

MySQL 8.0 버전부터는 래터럴 조인이라는 기능을 이용해 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것이 가능해졌다.

레터럴 조인에서 가장 중요한 부분은 FROM 절에 사용된 서브쿼리에서 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것이다.

LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기 때문에 꼭 필요한 경우에만 사용해야 한다.

### (7) 실행 계획으로 인한 정렬 흐트러짐

네스티드-루프 조인은 알고리즘 특성상 드라이빙 테이블에서 읽은 레코드의 순서가 다른 테이블이 모두 조인돼도 그대로 유지된다. 그래서 MySQL에서 조인을 사용하는 쿼리의 결과는 드라이빙 테이블을 읽은 순서로 정렬된다고 생각할 때가 많다. 실제로도 주어진 조건에 의해 드라이빙 테이블을 인덱스 스캔이나 풀 테이블 스캔을 하고, 그때 드라이빙 테이블을 읽은 순서가 그대로 최종 결과에 반영된다.

하지만 쿼리의 실행 계획에서 네스티드 루프 조인 대신 해시 조인이 사용되면 쿼리 결과의 레코드 정렬 순서가 달라진다. 해시 조인 뿐만 아니라 MySQL 8.0 이전 버전에서 사용되던 블록 네스티드 루프 조인이 사용되는 경우도 동일하게 쿼리 결과의 정렬 순서가 드라이빙 테이블을 읽는 순서와 다르게 출력된다.

실행 계획은 MySQL 옵티아미저에 의해 그때그때 상황에 따라 달라질 수 있다. 그러므로 정렬된 결과가 필요한 경우라면 드라이빙 테이블의 순서에 의존하지 말고 ORDER BY 절을 명시적으로 사용하는 것이 좋다.