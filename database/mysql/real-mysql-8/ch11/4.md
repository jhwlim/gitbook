---
description: Real MySQL 8.0
---

# 4. SELECT

웹 서비스 같이 일반적인 온라인 트랜잭션 처리 환경의 데이터베이스에서는 INSERT나 UPDATE 같은 작업은 거의 레코드 단위로 발생하므로 성능상 문제가 되는 경우는 별로 없다. 

하지만 SELECT는 여러 개의 테이블로부터 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을 어떻게 읽을 것인가에 많은 주의를 기울여야 한다. 하나의 애플리케이션에서 사용되는 쿼리 중에서도 SELECT 쿼리의 비율은 높다.

## 1. SELECT 절의 처리 순서

각 쿼리 절의 실행순서

- WHERE 적용 및 조인 실행 → GROUP BY → DISTINCT → HAVING 조건 적용 → ORDER BY → LIMIT
- ORDER BY 나 GROUP BY 절이 있더라도 인덱스를 이용해 처리할 때는 그 단계 자체가 불필요하므로 생략된다.

예외적으로 ORDER BY가 조인보다 먼저 실행되는 경우

- WHERE 적용 → ORDER BY → 조인 실행 → LIMIT
- 첫 번째 테이블만 읽어서 정렬을 수행한 뒤에 나머지 테이블을 읽는다.
- 주로 GROUP BY 절이 없이 ORDER BY만 사용된 쿼리에서 사용될 수 있는 순서다.

위에서 소개한 실행 순서를 벗어나는 쿼리가 필요하다면 서브쿼리로 작성된 **인라인 뷰**를 사용해야 한다.

- 예 : LIMIT를 먼저 적용하고 ORDER BY를 실행 (p54 참고)

하지만 인라인 뷰가 사용되면 임시 테이블이 사용되기 때문에 주의해야 한다.

WITH절(CTE, Common Table Expression)은 항상 제일 먼저 실행되어 임시 테이블로 저장된다. 그리고 WITH 절로 만들어진 임시 테이블은 단독으로 조회되거나 조인되는 테이블로 활용된다.

## 2. WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용

### (1) 인덱스를 사용하기 위한 기본 규칙

WHERE 절이나 ORDER BY 또는 GROUP BY가 인덱스를 사용하려면 기본적으로 인덱스된 칼럼 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다.

복잡한 연산을 수행한다거나 MD5() 함수와 같이 해시 값을 만들어서 비교해야 하는 경우라면 미리 계산된 값을 저장하도록 MySQL의 가상 칼럼을 추가하고, 그 칼럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용하면 된다.

결론적으로 인덱스의 칼럼을 변형해서 비교하는 경우에는 인덱스를 이용할 수 없게 된다는 점에 주의해야 한다.

추가로 WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다.

비교되는 두 값의 타입이 다를 때, MySQL 옵티마이저가 내부적으로 문자열 타입을 숫자 타입으로 변환한 후 비교 작업을 처리한다.

저장하고자 하는 값의 타입에 맞춰 칼럼을 선정하고, SQL을 작성할 때는 데이터의 타입에 맞춰서 비교 조건을 사용하길 권장한다.

### (2) WHERE 절의 인덱스 사용

WHERE 조건이 인덱스를 사용하는 방법은 크게 **작업 범위 결정 조건**과 **체크 조건**의 두 가지 방식으로 구분할 수 있다. 두 방식 중 작업 범위 결정 조건은 WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서부터 비교했을 때, 얼마나 일치하는가에 따라 달라진다.

WHERE 조건절에 나열된 순서가 인덱스와 다르더라도 MySQL 서버 옵티마이저는 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화를 수행할 수 있다.

GROUP BY나 ORDER BY와는 달리 WHERE 절의 조건절은 순서를 변경해도 결과의 차이가 없기 때문에, WHERE 절에서의 각 조건이 명시된 순서는 중요치 않고 인덱스를 구성하는 칼럼에 대한 조건이 있는지 없는지가 중요하다.

각 조건이 OR로 연결되면 읽어서 비교해야 할 레코드가 더 늘어나기 때문에 WHERE 조건에 OR 연산자가 있다면 주의해야 한다.

### (3) GROUP BY 절의 인덱스 사용

GROUP BY 절의 각 칼럼은 비교 연산자를 가지지 않으므로 작업 범위 결정 조건이나 체크 조건과 같이 구분해서 생각할 필요는 없다. GROUP BY 절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면 GROUP BY 절은 일단 인덱스를 이용할 수 있다.

**GROUP BY 절의 인덱스 사용 규칙**

- GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야 한다.
- 인덱스를 구성하는 칼럼 중에서 뒤쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만, 인덱스의 앞쪽에 있는 칼럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
- WHERE 조건절과 달리 GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다.

### (4) ORDER BY 절의 인덱스 사용

ORDER BY 절의 인덱스 사용 여부는 GROUP BY의 요건과 거의 흡사하지만, ORDER BY는 조건이 하나 더 있다. 정렬되는 각 칼럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다.

인덱스의 모든 칼럼이 ORDER BY 절에 사용돼야 하는 것은 아니지만, ORDER BY 절의 칼럼들이 인덱스에 정의된 칼럼의 왼쪽부터 일치해야 한다.

### (5) WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용

SQL 문장이 WHERE 절과 ORDER BY 절을 가지고 있다고 가정할 때, WHERE 조건은 A 인덱스를 사용하고, ORDER BY 는 B 인덱스를 사용하도록 쿼리가 실행될 수는 없다. 이는 WHERE 절과 GROUP BY 절이 같이 사용된 경우와 GROUP BY와 ORDER BY가 같이 사용된 쿼리에서도 마찬가지다.

- WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용 : 훨씬 빠른 성능을 보이기 때문에 가능하다면 이 방식으로 처리할 수 있게 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.
- WHERE 절만 인덱스를 이용 : 주로 WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을 때 효율적인 방식
- ORDER BY 절만 인덱스를 이용 : 주로 아주 많은 레코드를 조회해서 정렬해야 할 때 이런 형태로 튜닝하기도 한다.

또한 WHERE 절에서 동등 비교 조건으로 비교된 칼럼과 ORDER BY 절에 명시된 칼럼이 순서대로 빠짐없이 인덱스 칼럼의 왼쪽부터 일치해야 한다.

하지만 중간에 빠지는 칼럼이 있으면, WHERE 절이나 ORDER BY 절 모두 인덱스를 사용할 수 없다. 이때는 주로 WHERE 절만 인덱스를 이용할 수 있다.

ORDER BY 절에 해당 칼럼이 사용되고 있다면 WHERE 절에 동등 비교 이외의 연산자로 비교돼도 WHERE 조건과 ORDER BY 조건이 모두 인덱스를 할 수 있다. 일반적으로 WHERE 절에서 동등 비교로 사용된 칼럼과 ORDER BY 절의 칼럼이 인덱스를 구성하는 칼럼과 같은 순서로 연속해서 사용됐는지를 확인해야 한다.

예시 : COL_1, COL_2, COL_3  인덱스

```sql
-- 인덱스 사용 가능
SELECT * FROM tb_test WHERE COL_1 = 10 ORDER BY COL_2, COL_3; // 동등 조건
SELECT * FROM tb_test WHERE COL_1 > 10 ORDER BY COL_1, COL_2, COL_3; // 범위 조건

-- 인덱스 사용 불가
SELECT * FROM tb_test WHERE COL_1 > 10 ORDER BY COL_2, COL_3; // 범위 조건
```

WHERE 절과 ORDER BY나 GROUP BY 절의 조합에서 인덱스의 사용 여부를 판단하는 능력은 상당히 중요하므로 여러 가지 경우에 대해 직접 테스트해보는 것이 좋다.

### (6) GROUP BY 절과 ORDER BY 절의 인덱스 사용

GROUP BY와 ORDER BY 절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 GROUP BY 절에 명시된 칼럼과 ORDER BY에 명시된 칼럼의 순서와 내용이 모두 같아야 한다.

GROUP BY와 ORDER BY가 같이 사용된 쿼리에서는 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못한다. 즉, GROUP BY는 인덱스를 이용할 수 있지만 ORDER BY가 인덱스를 이용할 수 없을 때, 이 쿼리의 GROUP BY와 ORDER BY 절은 모두 인덱스를 이용하지 못한다. 그 반대의 경우도 마찬가지다.

### (7) WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용

WHERE 절과 GROUP BY 절, ORDER BY 절이 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법

1. WHERE 절이 인덱스를 사용할 수 있는가?
2. GROUP BY 절이 인덱스를 사용할 수 있는가?
3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?

## 3. WHERE 절의 비교 조건 사용 시 주의사항

쿼리가 최적으로 실행되려면 적합한 인덱스와 함께 WHERE 절에 사용되는 비교 조건의 표현식을 적절하게 사용해야 한다.

### (1) NULL 비교

MySQL에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다. 이는 인덱스에서는 NULL을 하나의 값으로 인정해서 관리한다는 것을 의미한다.

SQL 표준에서는 NULL의 저의는 비교할 수 없는 값이다. 그래서 두 값이 모두 NULL을 가진다고 하더라도 이 두 값이 동등한지 비교하는 것은 불가능하다. 연산이나 비교에서 한쪽이라도 NULL이면 그 결과도 NULL이 반환되는 이유가 바로 이 때문이다. 

쿼리에서 NULL인지 비교하려면 `IS NULL` (또는 `<=>`) 연산자를 사용해야 한다.

칼럼의 값이 NULL인지 확인할 때는 `ISNULL()` 이라는 함수를 사용해도 된다. 하지만 `ISNULL()` 함수를 WHERE 조건에서 사용할 때는 주의할 점이 있다.

```sql
-- 인덱스 사용 가능 : 인덱스 레인지 스캔
SELECT * FROM titles WHERE to_date IS NULL; 
SELECT * FROM titles WHERE ISNULL(to_date); 

-- 인덱스 사용 불가 : 인덱스 풀 스캔 또는 테이블 풀 스캔
SELECT * FROM titles WHERE ISNULL(to_date)=1;
SELECT * FROM titles WHERE ISNULL(to_date)=true;
```

NULL을 비교할 때는 가급적 `IS NULL` 연산자를 사용하길 권장한다.

### (2) 문자열이나 숫자 비교

문자열 칼럼이나 숫자 칼럼을 비교할 때는 반드시 그 타입에 맞는 상수값을 사용할 것을 권장한다.

칼럼의 타입에 맞게 상수 리터럴을 비교 조건에 사용하는 것이 중요하다.

### (3) 날짜 비교

1. DATE 또는 DATETIME과 문자열 비교
    - DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다.
    - 칼럼의 타입이 DATE나 DATETIME 타입이면 별도로 문자열을 DATE나 DATETIME 타입으로 명시적으로 변환하지 않아도 MySQL 내부적으로 변환을 수행한다.
    - 칼럼의 타입을 강제적으로 문자열로 변경하면 인덱스를 효율적으로 사용하지 못하므로, 가능하면 DATE나 DATETIME 타입의 칼럼은 변경하지 말고 상수를 변경하는 형태로 조건을 사용하는 것이 좋다.
2. DATE와 DATETIME의 비교
    - DATETIME 값에서 시간 부분만 떼어버리고 비교하려면 DATE() 함수를 사용하면 된다. DATE() 함수는 DATETIME 타입의 값에서 시간 부분은 버리고 날짜부분만 반환하는 함수다.
    - DATETIME 타입의 값을 DATE 타입으로 만들지 않고, 그냥 비교하면 MySQL 서버가 DATE 타입의 값을 DATETIME으로 변환해서 같은 타입으로 만든 다음 비교를 수행한다.
    - DATETIME과 DATE 타입의 비교에서 타입 변환은 인덱스의 사용 여부에 영향을 미치지 않기 때문에, 성능보다는 쿼리의 결과에주의해서 사용하면 된다.
3. DATETIME과 TIMESTAMP의 비교
    - DATE나 DATETIME 타입의 값과 TIMESTAMP의 값을 별도의 타입 변환 없이 비교하면 문제없이 작동하고 실제 실행 계획도 인덱스 레인지 스캔을 사용해서 동작하는 것처럼 보이지만 사실은 그렇지 않다.
    - 칼럼이 DATETIME 타입이라면 FROM_UNIXTIME() 함수를 이용해 TIMESTAMP 값을 DATETIME 타입으로 만들어서 비교해야 한다.
    - 칼럼의 타입이 TIMESTAMP라면 UNIX_TIMESTAMP() 함수를 이용해 DATETIME을 TIMESTAMP로 변환해서 비교해야 한다.

### (4) Short-Circuit Evaluation

여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우, 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화

MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 ‘Short-Circuit Evaluation’ 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정한다.

그런데 WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 ‘Short-Circuit Evaluation’과는 무관하게 MySQL 서버는 그 조건을 가장 최우선으로 사용한다. 그래서 WHERE 조건절에 나열된 조건의 순서가 인덱스의 사용 여부를 결정하지는 않는다.

MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것이다.

물론 WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 된다.

## 4. DISTINCT

DISTINCT를 남용하는 것은 성능적인 문제도 있지만 쿼리의 결과도 의도한 바와 달라질 수 있다. 

(9.2.5. DISTINCT 처리 참고)

각 테이블 간의 업무적인 연결 조건을 이해하지 못하고 쿼리를 작성하는 경우, DISTINCT를 남용하는 경우가 발생할 수 있다. 테이블 간 조인 쿼리르 작성하는 경우 각 테이블 간의 조인이 1:1 조인인지 1:M 조인인지 업무적인 특성을 잘 이해 하는 것이 중요하다.

## 5. LIMIT n

LIMIT은 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용한다.

MySQL의 LIMIT은 WHERE 조건이 아니기 때문에 항상 쿼리의 가장 마지막에 실행된다.

LIMIT의 중요한 특성은 LIMIT에서 필요한 레코드 건수만 준비되면 즉시 쿼리르 종료한다는 것이다. 즉, 모든 레코드의 정렬이 완료되지 않았다고하더라도 상위 n개가 정렬되면 작업을 멈춘다.

- 정렬이나 그루핑 또는 DISTINCT가 없는 쿼리에서 LIMIT 조건을 사용하면 쿼리가 상당히 빨리 끝날 수 있다.
- LIMIT이 GROUP BY와 함께 사용되는 경우에는 LIMIT 절이 있더라도 실질적인 서버의 작업 내용을 크게 줄여주지는 못한다.
- DISTINCT와 함께 사용된 LIMIT은 실질적인 중복 제거 작업의 범위를 줄이는 역할을 한다. LIMIT 절이 작업량을 상당히 줄여줄 수 있다.
- 정렬을 수행하면서 필요한 n건이 완성되는 순간, 나머지 작업을 멈추고 결과를 사용자에게 반환한다. (필뇨한 만큼만 정렬되면 된다.) 하지만 크게 작업량을 줄여주지는 못한다.

쿼리 문장에 GROUP BY나 ORDER BY 같은 전체 범위 작업이 선행되더라도 LIMIT 절이 있다면 크지는 않지만 나름의 성능 향상은 있다고 볼 수 있다.

ORDER BY나 GROUP BY 또는 DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어주기 때문에 쿼리의 작업량을 상당히 줄여준다.

LIMIT의 제한사항으로는 LIMIT의 인자로 표현식이나 별도의 서브쿼리를 사용할 수 없다는 것이 있다.

LIMIT는 실제 쿼리의 성능은 사용자의 화면에 레코드가 몇 건 출력되는냐보다는 MySQL 서버가 그 결과를 만들어 내기 위해 어떠한 작업들을 했는지가 중요하다.

`LIMIT n, m` 에서 n과 m에 주어지는 수치가 매우 커질 수 있는데, 이런 경우에는 쿼리 실행에 상당히 오랜 시간 걸린다.

LIMIT 조건의 페이징이 처음 몇 개 페이지 조회로 끝나지 않을 가능성이 높다면, WHERE 조건절로 읽어야 할 위치를 찾고 그 위치에서 특정 개수만 읽는 형태의 쿼리를 사용하는 것이 좋다.

이때, 중복이나 누락이 발생할 수 있기 때문에, 조건으로 사용하는 칼럼이 유니크한지 주의해야 한다.

## 6. COUNT()

COUNT() 함수는 칼럼이나 표현식을 인자로 받으며, 특별한 형태로 `*` 를 사용할 수 있다. 여기서 `*` 는 SELECT 절에 사용될 때 처럼 모든 칼럼을 가져오라는 의미가 아니라 그냥 레코드 자체를 의미하는 것이다. 실제로 COUNT(*)라고 해서 레코드의 모든 칼럼을 읽는 형태로 처리하지 않는다. 그래서 COUNT(프라이머리 키) 또는 COUNT(1)과 같이 사용하지 않고, COUNT(*)라고 표현해도 동일한 처리 성능을 보인다.

MYISAM 스토리지 엔진을 사용하는 테이블은 항상 테이블의 메타 정보에 전체 레코드 건수를 관리한다. 그래서 WHERE 조건이 없는 COUNT(*) 쿼리는 빠르게 처리된다. 하지만 WHERE 조건이 있는 COUNT(*) 쿼리는 그 조건에 일치하는 레코드를 읽어 보지 않는 이상 알 수 없으므로, 일반적인 DBMS와 같이 처리된다.

InnoDB 스토리지 엔진을 사용하는 테이블에서는 WHERE 조건이 없는 COUNT(*) 쿼리라고 하더라도 직접 데이터나 인덱스를 읽어야만 레코드 건수를 가져올 수 있기 때문에 큰 테이블에서 COUNT() 함수를 사용하는 작업은 주의해야 한다.

테이블이 가진 대략적인 레코드 건수로 충분하다면 SELECT COUNT(*) 보다는 SHOW TABLE STATUS 명령으로 통계 정보를 참조하는 것도 좋은 방법이다. 통계 정보와 실제 레코드 건수와 차이가 있을 수 있는데, 이런 경우에는 ANALYZE TABLE 명령을 실행해 통계 정보를 갱신하면 된다.

COUNT(*) 쿼리에서 ORDER BY 절은 어떤 경우에도 필요치 않다. 그리고 LEFT JOIN 또한 레코드 건수의 변화가 없거나 아우터 테이블에서 별도의 체크를 하지 않아도 되는 경우에는 모두 제거하는 것이 성능상 좋다.

MySQL 8.0 버전부터는 SELECT COUNT(*) 쿼리에 사용된 ORDER BY 절은 옵티마이저가 무시하도록 개선됐다. 하지만 꼭 필요한 부분만 간결하게 사용해 쿼리를 작성하는 것은 쿼리의 복잡도를 낮추고 가독성을 높인다는 장점이 있다.

인덱스를 제대로 사용하도록 튜닝되지 못한 COUNT(*) 쿼리는 페이징해서 데이터를 가져오는 쿼리보다 몇 배 또는 몇십 배 더 느리게 실행될 수 있다. COUNT(*) 쿼리도 많은 부하를 일으키기 때문에 주의 깊게 작성해야 한다.

COUNT() 함수에 칼럼명이나 표현식이 인자로 사용되면 그 칼럼이나 표현식의 결과가 NULL이 아닌 레코드 건수만 반환한다. 그래서 NULL이 될 수 있는 칼럼을 COUNT() 함수에 사용할 때는 의도대로 쿼리가 작동하는지 확인하는 것이 좋다.

페이징할 때 전체 건수를 조회하는 작업은 피하는 것이 좋은데, 페이지 번호를 보여주는 방식보다는 이전, 다음 버튼만 표시하는 방식을 검토해볼 것을 권장한다.

## 7. JOIN

### (1) JOIN의 순서와 인덱스

인덱스 레이지 스캔은 인덱스를 탐색하는 단계와 인덱스를 스캔하는 과정으로 구분할 수 있다.

일반적으로 인덱스를 이용해서 쿼리하는 작업에서는 가져오는 레코드 건수가 소량이기 때문에, 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높은 편이다.

조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 된다.

하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽는 레코드 건수만큼 반복한다. 드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다. 그래서 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.

### (2) JOIN 칼럼의 데이터 타입

조인 칼럼 간의 비교에서 각 칼럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 이용할 수 없다.

인덱스 사용에 영향을 미치는 데이터 타입 불일치는 CHAR 타입과 VARCHAR 타입, 또는 INT 타입과 BIGINT 타입, 그리고 DATE 타입과 DATETIME 타입 사이에서는 발생하지 않는다.

문제가 될 가능성이 높은 비교 패턴

- CHAR 타입과 INT 타입의 비교와 같이 데이터 타입의 종류가 완전히 다른 경우
- 같은 CHAR 타입이더라도 문자 집합이나 콜레이션이 다른 경우 (utf8mb4_general_ci, latin1_general_ci)
- 같은 INT 타입이더라도 부호의 존재 여부가 다른 경우

### (3) OUTER JOIN의 성능과 주의사항

테이블의 데이터가 일관되지 않은 경우에만 아우터 조인이 필요한 경우이다.

필요한 데이터와 조인되는 테이블 간의 관계를 정확히 파악해서 꼭 필요한 경우가 아니라면 이너 조인을 사용하는 것이 업무 요건을 정확히 구현함과 동시에 쿼리의 성능도 향상 시킬 수 있다.

아우터 조인 쿼리를 작성하면서 많이 하는 또 다른 실수는 아우터로 조인되는 테이블에 대한 조건을 WHERE 절에 함께 명시하는 것이다.

```sql
SELECT *
FROM employees e
	LEFT JOIN dept_manager mgr ON mgr.emp_no = e.emp_no
WHERE mgr.dept_no = 'd0001';
```

- 아우터로 조인되는 테이블인 dept_manage의 dept_no = ‘d001’ 조건을 WHERE 절에 명시한 것은 잘못된 조인 방법이다.

정상적인 아우터 조인이 되게 만들려면 WHERE 절의 ‘mgr.dept_no = ‘d001’ 조건을 LEFT JOIN의 ON 절로 옮겨야 한다.

```sql
SELECT *
FROM employees e
	LEFT JOIN dept_manage mgr 
	ON mgr.emp_no = e.emp_no AND mgr.dept_no = 'd001';
```

예외적으로 OUTER JOIN으로 연결되는 테이블의 칼럼에 대한 조건을 WHERE 절에 사용해야 하는 경우가 있는데, 다음과 같이 안티 조인 효과를 기대하는 경우가 그렇다.

```sql
SELECT *
FROM employees e
	LEFT JOIN dept_manage dm ON dm.emp_no e.emp_no
WHERE dm.emp_no IS NULL
LIMIT 10;
```

- WHERE 절에 아우터로 조인된 dept_manage 테이블의 emp_no 칼럼이 NULL인 레코드들만 조회한다.

이런 형태의 요건이 아우터 테이블의 칼럼이 WHERE 절에 사용될 수 있는 유일한 경우다. 

그 외의 경우 MySQL 서버는 LEFT JOIN을 INNER JOIN으로 자동 변환한다.

### (4) JOIN과 외래키(FOREIGN KEY)

외래키는 조인과 아무런 연관이 없다. SQL로 테이블 간의 조인을 수행하는 것은 전혀 무관한 칼럼을 조인 조건으로 사용해도 문법적으로는 문제가 되지 않는다.

### (5) 지연된 조인 (Delayed JOIN)

조인을 사용해서 데이터를 조회하는 쿼리에 GROUP BY 또는 ORDER BY를 사용할 때 각 처리 방법에서 인덱스를 사용한다면 이미 최적으로 처리되고 있을 가능성이 높다. 하지만 그렇지 못하다면 MySQL 서버는 우선 모든 조인을 실행하고 난 다음 GROUP BY나 ORDER BY를 처리할 것이다.

**지연된 조인**이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미한다. 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있다.

물론 지연된 조인으로 개선된 쿼리는 임시 테이블을 한 번 더사용하기 때문에 느리다고 예상할 수 있지만, 임시 테이블에 저장할 레코드가 작기 때문에 메모리를 이용해 빠르게 처리된다. 실제 테스트를 해보면 지연된 조인으로 개선된 쿼리가 3~4배 정도는 더 빠르게 실행된다는 것을 확인할 수 있다.

지연된 조인은 경우에 따라 상당한 성능 향상을 가져올 수 있지만 모든 쿼리를 지연된 조인 형태로 개선할 수 있는 것은 아니다.

- LEFT (OUTER) JOIN 인 경우 : 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야 한다.
- INNER JOIN 인 경우 : 드라이빙 테이블과 드리븐 테이블이 1:1 또는 M:1 곤계임과 동시에 드라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야 한다.

지연된 조인은 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 한다.

### (6) 래터럴 조인 (Lateral JOIN)

MySQL 8.0 버전부터는 래터럴 조인이라는 기능을 이용해 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것이 가능해졌다.

레터럴 조인에서 가장 중요한 부분은 FROM 절에 사용된 서브쿼리에서 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것이다.

LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기 때문에 꼭 필요한 경우에만 사용해야 한다.

### (7) 실행 계획으로 인한 정렬 흐트러짐

네스티드-루프 조인은 알고리즘 특성상 드라이빙 테이블에서 읽은 레코드의 순서가 다른 테이블이 모두 조인돼도 그대로 유지된다. 그래서 MySQL에서 조인을 사용하는 쿼리의 결과는 드라이빙 테이블을 읽은 순서로 정렬된다고 생각할 때가 많다. 실제로도 주어진 조건에 의해 드라이빙 테이블을 인덱스 스캔이나 풀 테이블 스캔을 하고, 그때 드라이빙 테이블을 읽은 순서가 그대로 최종 결과에 반영된다.

하지만 쿼리의 실행 계획에서 네스티드 루프 조인 대신 해시 조인이 사용되면 쿼리 결과의 레코드 정렬 순서가 달라진다. 해시 조인 뿐만 아니라 MySQL 8.0 이전 버전에서 사용되던 블록 네스티드 루프 조인이 사용되는 경우도 동일하게 쿼리 결과의 정렬 순서가 드라이빙 테이블을 읽는 순서와 다르게 출력된다.

실행 계획은 MySQL 옵티아미저에 의해 그때그때 상황에 따라 달라질 수 있다. 그러므로 정렬된 결과가 필요한 경우라면 드라이빙 테이블의 순서에 의존하지 말고 ORDER BY 절을 명시적으로 사용하는 것이 좋다.

## 8. GROUP BY

### (1) WITH ROLLUP

GROUP BY가 사용된 쿼리에서는 그루핑된 그룹별로 소계를 가져올 수 있는 롤업(ROLLUP) 기능을 사용할 수 있다. ROLLUP으로 출력되는 소계는 단순히 최종 합만 가져오는 것이 아니라 GROUP BY에 사용된 칼럼의 개수에 따라 소계의 레벨이 달라진다. MySQL의 `GROUP BY … ROLLUP` 쿼리는 엑셀의 피벗 테이블과 거의 동일한 기능으로 생각하면 된다.

WITH ROLLUP과 함께 사용된 GROUP BY 쿼리의 결과는 그룹별로 소계를 출력하는 레코드가 추가되어 표시된다. 소계 레코드의 칼럼값은 항상 NULL로 표시된다는 점에 주의해야 한다.

소계나 총계 레코드는 항상 해당 그룹의 마지막에 나타난다.

예

```sql
SELECT 
	dept_np, COUNT(*)
FROM
	dept_emp
GROUP BY dept_no WITH ROLLUP;
```

결과

| dept_no | COUNT(*) |
| --- | --- |
| d001 | 20211 |
| d002 | 17346 |
| … | … |
| d009 | 23580 |
| NULL | 331603 |

MySQL 8.0 버전부터는 그룹 레코드에 표시되는 NULL을 사용자가 변경할 수 있게 GROUPING() 함수를 지원한다.

```sql
SELECT
	IF (GROUPING(first_name), 'All first_name', first_name) AS first_name,
	IF (GROUPING(last_name), 'All last_name', first_name) AS last_name,
	COUNT(*)
FROM employees
GROUP BY first_name, last_name WITH ROLLUP;
```

결과

| first_name | last_name | COUNT(*) |
| --- | --- | --- |
| Aamer | Anger | 1 |
| Aamer | … | … |
| Aamod | … | … |
| All first_name | All last_name | 300024 |

### (2) 레코드를 칼럼으로 변환해서 조회

GROUP BY나 집합 함수를 통해 레코드를 그루핑할 수 있지만 하나의 레코드를 여러 개의 칼럼으로 나누거나 변환하는 SQL 문법은 없다. 하지만 SUM()이나 COUNT() 같은 집합 함수와 `CASE WHEN … END` 구문을 이용해 레코드를 칼럼으로 변환하거나 하나의 칼럼을 조건으로 구분해서 2개 이상의 칼럼으로 변환하는 것은 가능하다. 

- 레코드를 칼럼으로 변환
    
    레코드를 칼럼으로 변환하는 작업을 할 때는 목적이나 용도에 맞게 COUNT, MIN, MAX 등의 집합 함수를 사용하면 된다.
    
    예시
    
    ```sql
    SELECT
    	SUM(CASE WHEN dept_no = 'd001' THEN emp_count ELSE 0 END) AS count_d001,
    	...
    	SUM(CASE WHEN dept_no = 'd009' THEN emp_count ELSE 0 END) AS count_d009,
    	SUM(emp_count) AS count_total
    FROM (
    	SELECT
    		dept_no, 
    		COUNT(*) AS emp_count
    	FROM
    		dept_emp
    	GROUP BY dept_no
    ) tb_derived;
    ```
    
    결과
    
    | count_d001 | … | count_d009 | count_total |
    | --- | --- | --- | --- |
    | 20211 | … | … | 331603 |
    - 부서 번호가 쿼리의 일부로 사용되기 때문에 부서 번호가 변경되거나 추가되면 쿼리까지 변경돼야 하는데, 동적으로 쿼리를 생성하는 방법 등으로 보완하면 된다.
    
- 하나의 칼럼을 여러 칼럼으로 분리
    
    `SUM(CASE WHEN …)`  문장은 소그룹을 특정 그룹으로 나누는 용도로 사용할 수 있다.
    
    ```sql
    SELECT
    	de.dept_no,
    	SUM(CASE WHEN e.hire_date BETWEEN '1980-01-01' AND '1989-12-31' THEN 1 ELSE 0 END) AS cnt_1980,
    	SUM(CASE WHEN e.hire_date BETWEEN '1990-01-01' AND '1999-12-31' THEN 1 ELSE 0 END) AS cnt_1990,
    	SUM(CASE WHEN e.hire_date BETWEEN '2000-01-01' AND '2009-12-31' THEN 1 ELSE 0 END) AS cnt_2000,
    	COUNT(*) AS cnt_total
    FROM
    	dept_emp de, employees e
    WHERE e.emp_no = de.emp_no
    GROUP BY de.dept_no;
    
    ```
    
    결과
    
    | dept_no | cnt_1980 | cnt_1990 | cnt_2000 | cnt_total |
    | --- | --- | --- | --- | --- |
    | d001 | 11038 | 9171 | 0 | 20211 |
    | d002 | 9580 | 7765 | 1 | 17346 |
    | … | … | … | … | … |
    

## 9. ORDER BY

🤔 ORDER BY 절이 사용되지 않으면 어떤 순서로 정렬될까?

- 인덱스 사용 → 인덱스에 정렬된 순서
- 인덱스 사용 X → 풀 테이블 스캔, InnoDB의 경우에는 항상 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우에는 기본적으로 프라이머리 키 순서대로 레코드를 가져온다.
- 임시 테이블 사용 → 예측 불가

ORDER BY 절이 없는 SELECT 쿼리 결과의 순서는 처리 절차에 따라 달라질 수 있다. 어떤 DBMS도 ORDER BY 절이 명시되지 않은 쿼리에 대해서는 어떠한 정렬도 보장하지 않는다.

### (1) ORDER BY 사용볍 및 주의사항

ORDER BY 절은 1개 또는 그 이상 여러 개의 칼럼으로 정렬을 수행할 수 있드며, 정렬 순서(오름차순, 내림차순) 칼럼별로 다르게 명시 할 수 있다. 일반적으로 정렬할 대상은 칼럼명이나 표현식으로 명시하지만 SELECT 되는 칼럼의 순번을 명시할 수도 있다.

하지만 ORDER BY 뒤에 숫자 값이 아닌 문자열 상수를 사용하는 경우에는 옵티마이저가 ORDER BY 절 자체를 무시한다. 칼럼명이라 하더라도 따옴표를 이용해 문자 리터럴로 표시하면 상수값으로 정렬하라는 의미가 된다. 상수값으로 정렬을 수행하는 것은 아무런 의마가 없으므로 옵티마이저는 문자 리터럴이 ORDER BY 절에 사용되면 모두 무시한다.

```sql
SELECT
	first_name, last_name
FROM employees
ORDER BY "last_name";
```

### (2) 여러 방향으로 동시 정렬

MySQL 8.0 이전 버전까지는 여러 개의 칼럼을 조합해서 정렬할 때 각 칼럼의 정렬 순서가 오름차순과 내림차순이 혼용되면 인덱스를 이용할 수 없다.

하지만 MySQL 8.0 버전부터는 오름차순과 내림차순을 혼용해서 인덱스를 생성할 수 있게 개선됐다.

응용 프로그램에서 오름차순과 내림차순을 혼용해서 정렬하고자 하는 경우에는 ASC와 DESC 옵션을 섞어서 하나의 인덱스를 생성하면 된다.

```sql
ALTER TABLE salaries ADD INDEX ix_salary_fromdate (salary DESC, from_date ASC);
```

쿼리가 내림차순으로만 레코드를 정렬해서 가져간다면 인덱스는 당연히 DESC 로 생성하는 것이 좋다.

(8.3.6.1.2. 내림차순 인덱스 참조)

### (3) 함수나 표현식을 이용한 정렬

하나 또는 여러 칼럼의 연산 결과를 이용해 정렬하는 것도 가능하다.

MySQL 8.0 이전까지는 연산의 결과를 기준으로 정렬하기 위해서는 가상 칼럼을 추가하고, 인덱스를 생성하는 방법을 사용해야 했다.

하지만 MySQL 8.0 버전부터는 함수 기반의 인덱스를 지원하기 시작했다. (8.6. 함수 기반 인덱스 참조)

## 10. 서브쿼리

쿼리를 작성할 때 서브쿼리를 사용하면 단위 처리별로 쿼리를 독립적으로 작성할 수 있다. 조인처럼 여러 테이블을 섞어 두는 형태가 아니어서 쿼리의 가독성도 높아지며, 복잡한 쿼리도 손쉽게 작성할 수 있다.

MySQL 5.6 버전까지는 서브쿼리를 최적으로 실행하지 못할 때가 많았지만, MySQL 8.0 버전부터는 서브쿼리 처리가 많이 개선됐다.

서브쿼리는 SELECT 절과 FROM 절, WHERE 절 등 쿼리의 여러 위치에서 사용될 수 있다. 하지만 사용되는 위치에 따라 쿼리의 성능 영향도와 MySQL 서버의 최적화 방법은 완전히 달라진다.

### (1) SELECT 절에 사용된 서브쿼리

SELECT 절에 사용된 서브쿼리는 내부적으로 임시 테이블을 만들거나 쿼리를 비효율적으로 실행하게 만들지는 않기 때문에 서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의할 사항은 없다.

일반적으로 SELECT 절에 서브쿼리를 사용하면 그 서브쿼리는 항상 칼럼과 레코드가 하나인 결과를 반환해야 한다. 그 값이 NULL이든 아니든 관계없이 레코드가 1건이 존재해야 한다는 것인데, MySQL에서는 이 체크 조건이 조금 느슨하다.

SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리만 사용할 수 있다.

```sql
SELECT
	emp_no, (
		SELECT dept_name
		FROM departments
		WHERE dept_name = 'Sales1'
	)
FROM dept_emp
LIMIT 10;
```

서브쿼리는 만들어낸 결과에 따라 스칼라 서브쿼리와 로우 서브쿼리로 구분할 수 있다.

- 스칼라 서브쿼리 : 레코드의 칼럼이 각각 하나만 결과를 만들어내는 서브쿼리
- 로우 서브쿼리 (레코드 서브쿼리) : 스칼라 서브쿼리보다 레코드 건수가 많거나 칼럼 수가 많은 결과를 만들어 내는 서브쿼리

서브쿼리로 실행될 때보다 조인으로 처리할 때가 조금 더 빠르기 때문에 가능하다면 조인으로 쿼리를 작성하는 것이 좋다.

처리해야 하는 레코드 건수가 많아지면 많아질수록 성능 차이가 커질 수도 있으므로 가능하면 조인으로 쿼리를 작성하는 방법을 권장한다.

SELECT 절에 동일한 서브쿼리가 여러 번 사용되는 경우, MySQL 8.0 버전부터 도입된 래터럴 조인을 이용하면 동일한 레코드의 각 칼럼을 가져오기 위해서 서브쿼리를 3번씩이나 남용되지 않아도 된다.

```sql
SELECT
	e.emp_no,
	e.first_name,
	(
		SELECT s.salary 
		FROM salaries s
		WHERE s.emp_no = e.emp_no
		ORDER BY s.from_date DESC
		LIMIT 1
	) AS salary,
	(
		SELECT s.from_date 
		FROM salaries s
		WHERE s.emp_no = e.emp_no
		ORDER BY s.from_date DESC
		LIMIT 1
	) AS salary_from_date,
	(
		SELECT s.to_date 
		FROM salaries s
		WHERE s.emp_no = e.emp_no
		ORDER BY s.from_date DESC
		LIMIT 1
	) AS salary_to_date
FROM employees e
WHERE e.emp_no = 499999;

-- 래터럴 조인으로 변경
SELECT
	e.emp_no,
	e.first_name,
	s2.salary,
	s2.from_date,
	s2.to_date
FROM employees e
	INNER JOIN LATERAL (
		SELECT * 
		FROM salaries s
		WHERE s.emp_no = e.emp_no
		ORDER BY s.from_date DESC
		LIMIT 1
	) s2 ON s2.emp_no = e.emp_no
WHERE e.emp_no = 499999;
```

래터럴 조인의 문제점

- 래터럴 조인은 내부적으로 임시 테이블을 생성하기 때문에 Handler_write 값과 Handler_read_key 값이 증가할 수 있다. 그리고 서브쿼리를 사용한 경우는 salaries 테이블을 여러 번 읽기 때문에 Handler_read_key 값이 증가할 수 있는 실행 계획이 맞다.
- 래터럴 조인을 사용한 경우, 실행 계획에서 “Using filesort”가 표시되는 것을 확인할 수 있는데, 인덱스를 이용해 충분히 정렬된 결과를 가져올 수 있음에도 불구하고, 정렬을 실행했으며, 이로 인해 Handler_read_next 값이 증가했다. 이는 MySQL 8.0 버전의 버그로 식별됐는데, 아직 이 버그는 해결되지 않은 상태이다.

### (2) FROM 절에 사용된 서브쿼리

이전 버전의 MySQL 서버에서는 FROM 절에 서브쿼리가 사용되면 항상 서브쿼리의 결과를 임시 테이블로 저장하고 필요할 때 다시 임시 테이블을 읽는 방식으로 처리헀다. 그래서 가능하면 FROM 절의 서브 외부 쿼리로 병합하는 형태로 쿼리 튜닝을 했다.

하지만 MySQL 5.7 버전부터는 옵티마이저가 FROM 절의 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선됐다. 서브쿼리의 외부 쿼리 병합은 꼭 FROM 절의 서브쿼리에 대해서만 적용되는 최적화는 아니다. FROM 절에 사용된 뷰(View)의 경우에도 MySQL 옵티마이저는 뷰 쿼리와 외부 쿼리를 병합해서 최적화된 실행 계획을 사용한다.

FROM 절의 모든 서브쿼리를 외부 쿼리로 병합할 수 있는 것은 아니다. 다음과 같은 기능이 서브쿼리에 사용되면 FROM 절의 서브쿼리는 외부 쿼리로 병합되지 못한다.

- 집합 함수 사용 : SUM(), MIN(), MAX() 등
- DISTINCT
- GROUP BY 또는 HAVING
- LIMIT
- UNION (UNION DISTINCT) 또는 UNION ALL
- SELECT 절에 서브쿼리가 사용된 경우
- 사용자 변수 사용 (사용자 변수에 값이 할당되는 경우)

외부 쿼리와 병합되는 FROM 절의 서브쿼리가 ORDER BY 절을 가진 경우에는 외부 쿼리가 GROUP BY 나 DISTINCT 같은 기능을 사용하지 않는다면 서브쿼리의 정렬 조건을 외부 쿼리로 같이 병합한다. 외부 쿼리에서 GROUP BY 나 DISTINCT와 같은 기능이 사용되고 있다면, 서브쿼리의 정렬 작업은 무의미하기 때문에 서브쿼리의 ORDER BY 절을 무시된다.

MySQL 서버에서 FROM 절의 서브쿼리를 외부 쿼리로 병합하는 최적화는 `optimizer_switch` 시스템 변수로 제어할 수 있다. (9.3.1.16. 파생 테이블 머지 참고)

### (3) WHERE 절에 사용된 서브쿼리

WHERE 절의 서브 쿼리는 SELECT 절이나 FROM 절보다는 다양한 형태(연산자)로 사용될 수 있다.

- 동등 또는 크다 작다 비교
    - MySQL 5.5 이전 버전까지는 서브 쿼리 외부의 조건으로 쿼리를 실행하고, 최종적으로 서브쿼리를 체크 조건으로 사용했는데, 이러한 처리 방식의 경우 풀 테이블 스캔이 필요한 경우가 많아서 성능 저하가 심각했다.
    - MySQL 5.5 버전부터는 서브 쿼리를 먼저 실행한 후 상수로 변환한다. 그리고 상수값으로 서브쿼리를 대체해서 나머지 쿼리 부분을 처리한다.
    - 단일 값 비교가 아닌 튜플 비교 방식이 사용되면 서브쿼리가 먼저 처리되어 상수화되기 하지만, 외부 쿼리는 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하기 때문에 MySQL 8.0 버전에서도 튜플 형태의 비교는 주의해서 사용해야 한다.
- IN 비교 ( IN (subquery) )
    - 세미 조인 : 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식(또는 칼럼 그 자체)과 일치하는지를 체크하는 형태, 즉 WHERE 절에 사용된 IN (subquery) 형태의 조건을 조인의 한 방식
    - MySQL 5.5 버전까지는 세미 조인의 최적화가 매우 부족해서 대부분 풀 테이블 스캔을 했다.
    - MySQL 5.6 버전부터 8.0 버전까지는 세미 조인의 최적화가 많이 개선되면서 In (subquery) 형태를 2개의 쿼리로 쪼개어 실행하거나 다른 우회 방법을 찾을 필요가 없어졌다.
    - 세미 조인 최적화는 쿼리 특성이나 조인 관게에 맞게 다음의 5개 최적화 전략을 선택적으로 사용한다. (9.3.1.9. 세미 조인 참고)
        - 테이블 풀-아웃
        - 퍼스트 매치
        - 루스 스캔
        - 구체화
        - 중복 제거
    - MySQL 8.0을 사용한다면 세미 조인 최적화에 익숙해져야 한다. 에전처럼 불필요하게 쿼리를 여러 조각으로 분리해서 실행하는 습관은 버리고, MySQL 8.0의 기능을 적극 활요해 개발 생산성을 높이는 방향을 추천한다.
- NOT IN 비교 ( NOT IN (subquery) )
    - 안티 세미 조인
    - 일반적으로 RDBMS에서 Not-Equal 비교는 인덱스를 제대로 활용할 수 없듯이 안티 세미 조인 또한 최적화할 수 있는 방법이 많지 않다.
        - NOT EXISTS
        - 구체화
    - 위의 두가지 최적화 모두 그다지 성능 향상에 도움이 되지 않는 방법이므로 쿼리가 최대한 다른 조건을 활용해서 데이터 검색 범위를 좁힐 수 있게 하는 것이 좋다.
    - WHERE 절에 단독으로 안티 세미 조인 조건만 있다면 풀 테이블 스캔을 피할 수 없으니 주의하자.

## 11. CTE (Common Table Expression)

CTE는 이름을 가지는 임시 테이블로서, SQL 문장 내에서 한 번 이상 사용될 수 있으며, SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제된다.

CTE는 재귀적 반복 실행 여부를 기준으로 Non-recursive와 Recursive CTE로 구분된다.

### (1) 비 재귀적 CTE (Non-Recursive CTE)

MySQL 서버에서는 ANSI 표준을 그대로 이용해서 WITH 절을 이용해 CTE를 정의한다.

예시

```sql
WITH cte1 AS (
	SELECT * FROM departments
)
SELECT * FROM cte1;

SELECT *
FROM (
	SELECT * FROM departments
) cte1;
```

CTE는 여러 개의 임시 테이블을 하나의 쿼리에서 사용할 수도 있다.

```sql
WITH 
	cte1 AS (SELECT * FROM departments),
	cte2 AS (SELECT * FROM dept_emp)
SELECT *
FROM cte1
	INNER JOIN cte2 ON cte2.dept_no = cte1.dept_no;
```

CTE로 생성된 임시 테이블은 다른 CTE 쿼리에서 참조할 수 있다.

CTE를 재귀적으로 사용하지 않더라도 기존 FROM 절에 사용되던 서브쿼리에 비해 다음 3가지 장점이 있다.

- CTE 임시 테이블은 재사용 가능
- CTE로 선언된 임시 테이블은 다른 CTE 쿼리에서 참조 가능
- CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높다.

### (2) 재귀적 CTE (Recursive CTE)

MySQL 8.0 버전에서 CTE를 이용한 재귀 쿼리가 가능해졌다.

재귀적 CTE 쿼리는 비 재귀적 쿼리 파트와 재귀적 파트로 구분되며, 이 둘을 UNION(UNION DISTINCT) 또는 UNION ALL로 연결하는 형태로 반드시 쿼리를 작성해야 한다.

예시

```sql
WITH RECURSIVE cte (no) AS (
	SELECT 1
	UNION ALL
	SELECT (no + 1) FROM cte WHERE no < 5
)
SELECT * FROM cte;
```

- 비재귀적 파트 : `SELECT 1`
- 재귀적 파트 : `SELECT (no + 1) FROM cte WHERE no < 5`
- 비재귀적 파트는 처음 한 번만 실행되지만, 재귀적 파트는 쿼리 결과가 없을 때까지 반복 실행된다.
- 작동 방법
    1. 비재귀적 파트의 쿼리 실행
    2. 1번의 결과를 이용해 cte 임시 테이블 생성
    3. 1번의 결과를 cte 임시 테이블에 저장
    4. 1번의 결과를 입력으로 사용해, 재귀적 파트의 쿼리 실행
    5. 4번의 결과를 cte 임시 테이블에 저장, 이때 UNION 또는 UNION DISTINCT의 경우 중복 제거 수행
    6. 전 단계의 결과를 입력으로 사용해, 재귀적 파트의 쿼리 실행
    7. 6번 단계에서 쿼리 결과가 없으면 CTE 쿼리 종료
    8. 6번의 결과를 cte 임시 테이블에 저장
    9. 6번으로 돌아가서 반복 실행

CTE 임시 테이블의 구조(테이블의 칼럼명과 칼럼의 데이터 타입)는 CTE 쿼리의 비 재귀적 쿼리 파트의 결과로 결정된다. (1번 과정)

CTE의 비 재귀적 쿼리 파트는 초기 데이터와 임시 테이블의 구조를 준비하고, 재귀적 쿼리 파트에서는 이후 데이터를 생성해내는 역할을 한다.

재귀적 쿼리 파트를 실행할 때는 직전 단계의 결과만 재귀 쿼리의 입력으로 사용된다.

재귀적으로 실행되는 CTE에서 하나 더 주의해야 할 것은 반복 실행의 종료 조건이다. 실제 재귀 쿼리가 반복을 멈추는 조건은 재귀 파트 쿼리의 결과가 0건일 때까지다.

데이터의 오류나 쿼리 작성자의 실수로 재귀적 CTE가 종료 조건을 만족하지 못해서 무한 반복하는 경우도 발생할 수 있다. 이 같은 오류를 막기 위해서 `cte_max_recursion_depth` 시스템 변수를 이용해 최대 반복 실행 횟수를 제한할 수 있다. 기본값은 1000으로 큰 편인데, 가능하면 적절히 낮은 값으로 변경하고, 꼭 필요한 쿼리에서만 SET_VAR 힌트를 이용해 해당 쿼리에서만 반복 호출 횟수를 늘리는 방법을 권장한다.

### (3) 재귀적 CTE (Recursive CTE) 활용

재귀적 쿼리를 활용할 수 있는 업무요건은 상당히 많다.

- 단순히 1 부터 단조 증가하는 값을 가지는 임시 테이블
- 일 단위로 증가하는 날짜를 가진 임시 테이블
- 조직도 조회
- BOM (Bill Of Material) 쿼리

재귀적 쿼리 파트는 조금은 혼란스러울 수 있는데, 작동 원리만 이해하면 어렵지 않게 자유자재로 쿼리를 작성할 수 있을 것이다. CTE를 사용하는 방법은 자세히 공부해두면 개발에 많은 도움이 될 것이다.

## 12. 윈도우 함수 (Window Function)

- 윈도우 함수는 조회하는 현재 레코드를 기준으로 연관된 레코드 집합의 연산을 수행한다.
- **집계 함수와의 차이점**
    - 집계 함수는 주어진 그룹별로 하나의 레코드로 묶어서 출력하지만, 윈도우 함수는 조건에 일치하는 레코드 건수는 변하지 않는다.
    - 일반적인 SQL 문장에서 하나의 레코드를 연산할 때, 다른 레코드의 값을 참조할 수 없는데, 예외적으로 GROUP BY 또는 집계 함수를 이용하면 다른 레코드의 칼럼값을 참조할 수 있다. 하지만 GROUP BY 또는 집계 함수를 사용하면 결과 집합의 모양이 바뀐다. 반면에 윈도우 함수는 결과 집합을 그대로 유지하면서 하나의 레코드 연산에 다른 레코드의 칼럼값을 참조할 수 있다.

### (1) 쿼리 각 절의 실행 순서

윈도우 함수를 사용하는 쿼리의 실행 순서

1. FROM 절, WHERE 절, GROUP BY와 HAVING 절
2. 윈도우 함수
3. SELECT 절, ORDER BY 절, LIMIT 절

위의 순서를 벗어나는 쿼리를 작성하고자 한다면 FROM 절의 서브쿼리를 사용해야 한다.

예시

```sql
SELECT
	emp_no,
	from_date,
	salary,
	AVG(salary) OVER() AS avg_salary
FROM salaries
WHERE emp_no = 10001
LIMIT 5;
```

- 실행 순서
    1. `emp_no = 10001` 조건에 일치하는 레코드를 모두 가져온다.
    2. `AVG(salary) OVER())` 윈도우 함수 실행
- 실행 결과 : `emp_no = 10001` 조건을 만족하는 모든 레코드의 평균

```sql
SELECT
	emp_no,
	from_date,
	salary,
	AVG(salary) OVER() AS avg_salary
FROM (
	SELECT *
	FROM salaries
	WHERE emp_no = 10001
	LIMIT 5
) s2;
```

- 실행 결과 : 서브 쿼리 (5개의 레코드)에 대한 평균

### (2) 윈도우 함수 기본 사용법

기본 사용법

```sql
AGGREGATE_FUNC() OVER(<partition> <order>) AS window_func_column
```

- 집계 함수와는 달리 함수 뒤에 OVER 절을 이용해 연산 대상을 파티션하기 위한 옵션을 명시할 수 있다.
- 이렇게 OVER 절에 의해 만들어진 그룹을 **파티션** 또는 **윈도우** 라고 한다.
- 소그룹 파티션이나 정렬이 필요하지 않은 경우, PARTITION 이나 ORDER BY 없이 비어 있는 OVER() 절을 하면 된다.

예시

```sql
SELECT
	e.*,
	RANK() OVER(ORDER BY e.hire_date) AS hire_date_rank
FROM employees e;
```

- `e.hire_date` 칼럼으로 정렬한 후 순위(`RANK()`)를 매김

```sql
-- 부서 별 입사 순위
SELECT 
	de.dept_no,
	e.emp_no,
	e.first_name,
	e.hire_date,
	RANK() OVER(PARTITION BY de.dept_no ORDER BY e.hire_date) AS hire_date_rank
FROM employees e
	INNER JOIN dept_emp de ON de.emp_no = e.emp_no
ORDER BY de.dept_no, e.hire_date;
```

윈도우 함수의 각 파티션 안에서도 연산 대상 레코드 별로 연산을 수행할 소그룹이 사용되는데, 이를 **프레임**이라고 한다. 윈도우 함수에서 프레임을 명시적으로 지정하지 않아도 MySQL 서버는 상황에 맞게 프레임을 묵시적으로 선택한다. 프레임은 레코드의 순서대로 현재 레코드 기준 앞뒤 몇 건을 연산 범위로 제한하는 역할을 한다.

```sql
AGGREGATE_FUNC() OVER(<partition> <order> <frame>) AS window_func_column
```

자세한 프레임 절을 사용하는 방법은 p129~133 참고

윈도우 함수에서 프레임이 별도로 명시되지 않으면 무조건 파티션의 모든 레코드가 연산의 대상이 되는 것은 아니다. OVER() 절이 ORDER BY를 가지는지 여부에 따라 묵시적인 프레임의 범위가 달라진다.

- ORDER BY절을 가지는 경우 : 파티션의 첫 번째 레코드부터 현재 레코드까지가 프레임이 된다.
- ORDER BY절을 가지지 않는 경우 : 모든 레코드가 묵시적인 프레임으로 선택된다.

일부 윈도우 함수들은 프레임이 미리 고정돼 있다. SQL 문장에서 프레임을 별도로 명시하더라도 이러한 윈도우 함수에서는 사용자가 정의한 프레임은 모두 무시된다. (CUME_DIST(), DENSE_RANK(), LAG(), LEAD(), NTILE(), PERCENT_RANK(), RANK(), ROW_NUMBER())

### (3) 윈도우 함수

MySQL 서버의 윈도우 함수에는 집계 함수와 비 집계 함수를 모두 사용할 수 있다. 

- 집계 함수는 GROUP BY 절과 함께 사용할 수 있는 함수들을 의미하는데, 집계 함수는 OVER() 절 없이 단독으로도 사용될 수 있고, OVER() 절을 가진 윈도우 함수로도 사용될 수 있다.
- 비 집계 함수는 반드시 OVER() 절을 가지고 있어야 하며, 윈도우 함수로만 사용될 수 있다.

1. DENSE_RANK()와 RANK(), ROW_NUMBER()
    - DENSE_RANK() 함수와 RANK() 함수는 모두 ORDER BY 기준으로 매겨진 순위를 반환한다.
    - RANK() : 동점인 레코드가 두 건 이상인 경우 그 다음 레코드를 동점인 레코드 수만큼 증가시킨 순위를 반환
    - DENSE_RANK() : 동점인 레코드를 1건으로 가정하고, 순위를 매기기 때문에 연속된 순위를 가진다.
    - ROW_NUMBER() : 똑같이 순위를 매기지만, 이름 그대로 각 레코드의 고유한 순번을 반환한다. 그래서 동점에 대한 고려 없이 정렬된 순서대로 레코드 번호를 부여한다.
2. LAG()와 LEAD()
    - RAG() : 파티션 내에서 현재 레코드를 기준으로 n 번째 이전 레코드를 반환
    - LEAD() : 반대로 n 번째 이후 레코드를 반환

### (4) 윈도우 함수와 성능

MySQL 서버의 윈도우 함수는 8.0 버전에 처음 도입됐으며, 아직 인덱스를 이용한 최적화가 부족한 부분도 있다.

가능하다면 윈도우 함수에 너무 의존하지 않는 것이 좋다. 또한 배치 프로그램이라면 윈도우 함수를 사용해도 무방하겠지만, 온라인 트랜잭션 처리에서 많은 레코드에 대해 윈도우 함수를 적용하는 것은 가능하면 피하는 것이 좋다.

## 13. 잠금을 사용하는 SELECT

InnoDB 테이블에 대해서는 레코드를 SELECT할 때, 레코드에 아무런 잠금도 걸지 않는다. (잠금 없는 읽기)

하지만 SELECT 쿼리를 이용해 읽는 레코드의 칼럼 값을 애플리케이션에서 가공해서 다시 업데이트하고자 할 때는 SELECT가 실행된 후 다른 트랜잭션이 그 칼럼의 값을 변경하지 못하게 해야 한다. 이럴 때는 레코드를 읽으면서 강제로 잠금을 걸어 둘 필요가 있는데, 이때 사용하는 옵션이 `FOR SHARE`와 `FOR UPDATE` 절이다.

- `FOR SHARE` : SELEFCT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 건다.
    - MySQL 8.0 이전 버전에서는 LOCK IN SHARE MODE 절을 사용했고, 호환성 차원에서 8.0 버전에서도 지원됨. 하지만 `FOR SHARE` 절을 사용하는 것을 권장함.
- `FOR UPDATE` : SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 건다.

위의 두 가지 잠금 옵션은 모두 자동 커밋(AUTO-COMMIT)이 비활성화된 상태 또는 BEGIN 명령이나 START TRANSACTION 명령으로 트랜잭션이 시작된 상태에서만 잠금이 유지된다.

- `FOR SHARE` : SELECT 된 레코드에 대해 읽기 잠금을 설정하고, 다른 세션에서 해당 레코드를 변경하지 못하게 한다.  다른 세션에서 잠금이 걸린 레코드를 읽는 것은 가능하다.
- `FOR UPDATE` : UPDATE 절은 쓰기 잠금을 설정하고, 다른 트랜잭션에서는 그 레코드를 변경하는 것뿐만 아니라 읽기도 수행할 수 없다.

주의사항

InnoDB 스토리지 엔진을 사용하는 테이블에서는 잠금 없는 읽기가 지원되기 때문에 특정 레코드가 `SELECT ... FOR UPDATE` 쿼리에 의해서 잠겨진 상태라 하더라도 `FOR SHARE` 나 `FOR UPDATE` 절을 가지지 않은 단순 SELECT 쿼리는 아무런 대기 없이 실행된다.

### (1) 잠금 테이블 선택

```sql
SELECT *
FROM employees e
	INNER JOIN dept_emp de ON de.emp_no = e.emp_no
	INNER JOIN departments d ON d.dept_no = de.dept_no
FOR UPDATE;
```

- 3개의 테이블에서 읽은 레코드에 대해 모두 쓰기 잠금을 건다.

🤔 그런데 dept_emp 테이블과 departments 테이블은 그냥 참고용으로만 읽고, 실제 쓰기 잠금은 employees 테이블에만 걸고 싶다면?

- MySQL 8.0 버전부터는 잠금을 걸 테이블을 선택할 수 있도록 기능이 개선됐다.
- `FOR UPDATE` 뒤에 `OF 테이블` 절을 추가하면 해당 테이블에 대해서만 잠금을 걸게된다. 테이블에 대해 별명(Ailas)이 사용된 경우에는 별명을 명시해야 한다.
- `FOR UPDATE` 와 `FOR SHARE` 절 모두 적용 가능

```sql
SELECT *
FROM employees e
	INNER JOIN dept_emp de ON de.emp_no = e.emp_no
	INNER JOIN departments d ON d.dept_no = de.dept_no
FOR UPDATE OF e; 
```

### (2) NOWAIT & SKIP LOCKED

MySQL 8.0 버전부터 사용 가능

NOWAIT

- 해당 레코드가 다른 트랜잭션에 의해서 잠겨진 상태라면 에러를 반환하면서 쿼리는 즉시 종료된다.
- 레코드가 이미 잠겨진 상태라면 그냥 무시하고 즉시 에러를 반환하면 응용 프로그램에서 다른 처리를 수행하거나 다시 트랜잭션을 시작하도록 구현해야할 때 사용 가능
- `FOR UPDATE` 나 `FOR SHARE` 절이 없는 SELECT 쿼리는 잠금 대기 자체가 없기 때문에 NOWAIT 옵션을  사용하는 것은 의미 없음.

SKIP LOCKED

- SELECT 하려는 레코드가 다른 트랜잭션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않고, 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져온다.
- 확정적이지 않은 쿼리 (NOT-DETERMINISTIC)
    - 확정적(DETERMINISTIC) : 입력이 동일하면 시점에 관계없이 동일한 결과를 반환하는 것
    - SELECT 쿼리를 실행하는 시점에서 데이터의 변경이 엇는 상태에서도 각 트랜잭션의 간섭에 의해 다른 결과를 반환할 수 있다.
    - 이렇게 비확정적인 쿼리는 문장(STATEMENT) 기반의 복제에서 소스 서버와 레플리카 서버의 데이터를 다르게 만들수도 있다. 그래서 가능하면 복제의 바이너리 로그 포맷으로 STATEMENT보다는 ROW 또는 MIXED를 사용하는 것이 좋다.
- 트랜잭션이 수행되는데 걸리는 시간과 관계없이 다른 트랜잭션에 의해서 이미 사용 중인(잠겨진) 레코드를 스킵하는 시간만 지나면 각자의 트랜잭션을 실행할 수 있다.
- 동시에 유입된 트랜잭션들이 대기 시간 없이 잠긴 레코드를 스킵하고 사용 가능한 레코드를 찾기만 하면 즉시 트랜잭션 처리를 시작할 수 있다. → 여러 개의 트랜잭션을 동시에 처리하는 효과!
- 만약 `FOR UPDATE` 만 사용한 경우에는 동시에 유입된 트랜잭션이 모두 잠금 대기를 하고 있다가 첫 번째 레코드를 잠근 트랜잭션이 완료돼야 비로소 두 번째 트랜잭션이 시작될 수 있다.

NOWAIT이나 SKIP LOCKED 기능은 큐와 같은 기능을 MySQL 서버에서 구현하고자 할 때 매우 유용함.

NOWAIT나 SKIP LOCKED 절은 `SELECT ... FOR UPDATE` 구문에서만 사용할 수 있다.

UPDATE나 DELETE 쿼리에서는 사용할 수 없는데, NOWAIT나 SKIP LOCKED 절은 쿼리 자체를 비확정적으로 만들기 때문에 UPDATE나 DELETE 문장에서 사용된다면 실행될 때마다, 데이터베이스의 상태를 다른 결과로 만들게 된다. 즉 UPDATE나 DELETE 문장이 정상적으로 실행됐지만, 어떤 레코드가 업데이트되거나 삭제됐는지 알 수 없게 된다. 또한 MySQL 서버의 복제에서는 더 큰 문제를 일으킬 수도 있다.