---
description: Real MySQL 8.0
---

# 5. INSERT

일반적인 온라인 트랜잭션 서비스에서 INSERT 문장은 대부분 1건 또는 소량의 레코드를 INSERT 하는 형태이므로 그다지 성능에 대해서 고려할 부분이 많지 않다. 오히려 많은 INSERT 문장이 동시에 실행되는 경우 INSERT 문장 자체보다는 테이블의 구조가 성능에 더 큰 영향을 미친다.

하지만 많은 경우 INSERT의 성능과 SELECT의 성능을 동시에 빠르게 만들 수 있는 테이블 구조는 없다. 그래서 INSERT와 SELECT 성능을 어느 정도 타협하면서 테이블 구조를 설계해야 한다.

## 1. 고급 옵션

INSERT IGNORE 옵션과 INSERT … ON DUPLICATED KEY UPDATE 옵션은 두 유니크 인덱스나 프라이머리 키에 대해 중복 레코드를 어떻게 처리할지를 결정한다.

### (1) INSERT IGNORE

- 저장하는 레코드의 프라이머리 키나 유니크 인덱스 칼럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 칼럼이 테이블의 칼럼과 호환되지 안흔 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해준다.
- 주로 여러 레코드를 하나의 INSERT 문장으로 처리하는 경우 유용하다.
- INSERT 하고자 하는 데이터가 정교하지 않아도 되는 경우 INSERT를 실행하기 전에 레코드 건건이 중복 체크를 실행하지 않고 INSERT IGNORE 명령으로 처리하는 방식으로 자주 사용된다.
- INSERT하는 테이블이 프라이머리 키와 유니크 인덱스를 동시에 가지고 있는 경우 INSERT IGNORE는 두 인덱스 중 하나라도 중복이 발생하는 레코드에 대해서는 INSERT를 무시한다.
- 단순히 유니크 인덱스의 중복 뿐만 아니라 데이터 타입이 일치하지 않아서 INSERT를 할 수 없는 경우에도 칼럼의 기본 값으로 INSERT 하도록 만들기도 한다.
- (주의) 프로그램 코드에서 중복을 무시하기 위해 INSERT IGNORE 옵션을 사용한다면 데이터 중복 이외의 에러가 발생할 여지가 없는지 면밀히 확인한 후 적용하는 것이 좋다. 제대로 검증되지 않은 INSERT IGNORE 문장은 의도하지 않은 에러까지 모두 무시해버릴 수도 있다.

### (2) INSERT … ON DUPLICATE KEY UPDATE

프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATAE 문장의 역할을 수행하게 해준다.

REPLACE 문장도 비슷한 역할을 수행하지만, 내부적으로 DELETE와 INSERT 조합으로 작동한다.

하지만 INSERT … ON DUPLICATE KEY UPDATE 문장은 중복된 레코드가 있다면 기존 레코드를 삭제하지 않고, 기존 레코드의 칼럼을 UPDATE 하는 방식으로 작동한다.

일별로 집계되는 값을 관리할 때 편리하게 사용할 수 있다.

## 2. LOAD DATA 명령 주의사항

일반적으로 RDBMS에서 데이터를 빠르게 적재할 수 있는 방법으로 LOAD DATA 명령이 자주 소개된다.

MySQL 서버의 LOAD DATA 명령도 내부적으로 MySQL 엔진과 스토리지 엔진의 호출 횟수를 최소화하고, 스토리지 엔진이 직접 데이터를 적재하기 때문에 일반적인 INSERT 명령과 비교했을 때 매우 빠르다고 할 수 있다.

단점

- 단일 스레드로 실행
    - **데이터가 매우 커서 실행 시간이 아주 길어진다면 다른 온라인 트랜잭션 쿼리들의 성능이 영향을 받을 수 있다.**
    - 우선 LOAD DATA 명령은 단일 스레드로 실행되기 때문에 적재해야 할 데이터 파일이 매우 크다면 시간이 매우 길어질 수 있다. 테이블에 여러 인덱스가 있다면 LOAD DATA 문장이 레코드를 INSERT하고 인덱스에도 키 값을 INSERT 해야 한다. 이때, 테이블에 레코드가 INSERT되면 될수록 테이블과 인덱스의 크기도 커지게 된다. 하지만 LOAD DATA 문장은 단일 스레드로 실행되기 때문에 시간이 지나면 지날수록 INSERT 속도는 현저히 떨어진다.
- 단일 트랜잭션으로 실행
    - LOAD DATA 문장이 시작한 시점부터 언두 로그가 삭제되지 못하고 유지돼야 한다. 이는 언두 로그를 디스크로 기록해야 하는 부하를 만들기도 하지만, 언두 로그가 많이 쌓이면 레코드를 읽는 쿼리들이 필요한 레코드를 찾는데 더 많은 오버헤드를 만들어 내기도 한다.

가능하다면 LOAD DATA 문장으로 적재할 데이터 파일을 하나보다는 여러 개의 파일로 준비해서 LOAD DATA 문장을 동시에 여러 트랜잭션으로 나뉘어 실행되게 하는 것이 좋다. 

테이블 간 데이터 복사 작업이라면 LOAD DATA 문장보다는 INSERT … SELECT … 문장으로 WHERE 조건 절에서 데이터를 부분적으로 잘라서 효율적으로 INSERT 할 수 있게 해주는 것이 좋다.

## 3. 성능을 위한 테이블 구조

INSERT 문장의 성능은 쿼리 문장 자체보다는 테이블의 구조에 의해 많이 결정된다.

### (1) 대량 INSERT 성능

하나의 INSERT 문장으로 수백 건, 수천 건의 레코드를 INSERT 한다면 INSERT될 레코드들을 프라이머리 키 값 기준으로 미리 정렬해서 INSERT될 레코드들을 프라이머리 키 값 기준으로 미리 정렬해서 INSERT 문장을 구성하는 것이 성능에 도움이 될 수 있다.

테이블의 세컨더리 인덱스는 SELECT 문장의 성능을 높이지만, 반대로 INSERT 성능은 떨어진다. 세컨더리 인덱스도 정렬된 순서대로 INSERT 될 수 있다면 더 빠른 성능을 얻을 수 있다. 하지만 하나의 테이블에서 모든 세컨더리 인덱스가 저장되는 순서대로 정렬되게 보장하기는 어렵다. 이러한 이유로 테이블의 세컨더리 인덱스를 너무 남용하는 것은 성능상 좋지 않다.

### (2) 프라이머리 키 선정

InnoDB 스토리지 엔진을 사용하는 테이블의 프라이머리 키는 클러스터링 키인데, 이는 세컨더리 인덱스를 이용하는 쿼리보다 프라이머리 키를 이용하는 쿼리의 성능이 훨씬 빨라지는 효과를 낸다. 그래서 프라이머리 키는 단순히 INSERT 성능만을 위해 설계해서는 안 된다. 프라이머리 키의 선정은 INSERT 성능과 SELECT 성능의 대립되는 두가지 요소 중에서 하나를 선택해야 함을 의미한다. 이 두가지 요소를 모두 만족하는 프라이머리 키를 찾을 수 있다면 더할 나위 없이 좋다.

대부분 온라인 트랜잭션 처리를 위한 테이블은 쓰기보다는 읽기 쿼리의 비율이 압도적으로 높다. SELECT는 거의 실행되지 않고, INSERT가 매우 많이 실행되는 테이블이라면 테이블의 프라이머리 키를 단조 증가 또는 단조 감소하는 패턴의 값을 선택하는 것이 좋다.

일반적으로 SELECT에 최적화된 프라이머리 키는 단조 증가나 단조 감소 패턴과는 거리가 먼 경우가 많지만, 여전히 빈번하게 실행되는 SELECT 쿼리의 조건을 기준으로 프라이머리 키를 선택하는 것이 좋다.

또한 SELECT는 많지 않고 INSERT가 많은 테이블에 대해서는 인덱스의 개수를 최소화하는 것이 좋다. 반면 INSERT는 많지 않고 SELECT가 많은 테이블에 대해서는 쿼리에 맞게 필요한 인덱스들을 추가해도 시스템 전반적으로 영향도가 크지 않다.

(팁) 테이블을 설계할 때, 1~2백만 건 또는 그 이하의 레코드를 가지는 테이블에 대해 너무 많은 시간을 소모하지 않아도 된다. 테이블이 이미 작기 때문에 아무리 튜닝을 잘해도 얻을 수 있는 성능 효과가 크지 않기 때문이다. 물론 레코드 건수가 많지 않더라도 쿼리가 매우 빈번하게 실행된다면 튜닝에 신중을 기해야 한다.

소량의 테이블에 투자할 시간을 대량의 테이블에 투자해서 대용량의 테이블에 대한 쿼리들이 최적으로 작동할 수 있게 하자.

### (3) Auto-Increment 칼럼

INSERT에 최적화된 테이블을 생성하기 위해서는 다음 두 가지 요소를 갖춰 테이블을 준비하면 된다.

- 단조 증가와 단조 감소되는 값으로 프라이머리 키 선정
- 세컨더리 인덱스 최소화

InnoDB 스토리지 엔진을 사용하는 테이블은 자동으로 프라이머리 키로 클러스터링된다. 자동 증가(Auto Increment) 칼럼을 이용하면 클러스터링되지 않은 테이블의 효과를 얻을 수 있다.

자동 증가 값을 프라이머리 키로 해서 테이블을 생성하는 것은 MySQL 서버에서 가장 빠른 INSERT를 보장하는 방법이다.

MySQL 서버에서는 자동 증가 값의 채번을 위해서는 잠금이 필요한데, 이를 AUTO-INC 잠금이라고 한다.그리고 이 잠금을 사용하는 방식을 변경할 수 있게 `innodb_autoinc_lock_mode` 시스템 변수를 제공한다. 이 설정은 InnoDB 이외의 스토리지 엔진을 사용하는 테이블에는 영향을 미치지 않는다.

옵션

- `0`
    - 항상 AUTO-INC 잠금을 걸고 한 번에 1씩만 증가된 값을 가져온다.
    - 서비스용 MySQL 서버에서는 사용 안함.
- `1` (Consecutive mode)
    - 단순히 1 건씩 INSERT 하는 쿼리에서는 AUTO-INC 잠금을 사용하지 않고 뮤텍스를 이용해 더 가볍고 빠르게 처리한다.
    - 하나의 INSERT 문장으로 여러 레코드를 INSERT하거나 LOAD DATA 명령으로 INSERT 하는 쿼리에서는 AUTO-INC 잠금을 걸고 필요한 만큼의 자동 증가 값을 한꺼번에 가져와서 사용한다.
    - INSERT 순서대로 채번된 자동 증가 값은 일관되고, 자동 증가 값은 연속된 번호를 갖게 된다.
    - MySQL 5.7 버전까지의 기본값
- `2` (Interleaved mode)
    - LOAD DATA 나 벌크 INSERT를 포함한 INSERT 계열의 문장을 실행할 때, 더 이상 AUTO-INC 잠금을 사용하지 않는다. 이때 자동 증가 값을 적당히 미리 할당 받아서 처리할 수 있으므로 가장 빠른 방식
    - 채번된 번호는 단조 증가하는 유니크한 번호까지만 보장하며, INSERT 순서와 채번된 번호의 연속성은 보장하지 않는다.
    - 쿼리 기반의 복제를 사용하는 MySQL에서는 소스 서버와 레플리카 서버의 자동 증가 값이 동기화되지 모소할 수도 있으므로 주의해야 한다.
    - MySQL 8.0 버전에서의 기본값
    

MySQL 서버의 버전과 관계없이 복제를 STATEMENT 바이너리 로그 포맷으로 사용 중이라면 `1` 로 설정해야 한다.

자동 증가 값이 반드시 연속이어야 한다면 `2` 보다는 `1` 로 설정하는 것이 좋다. 하지만 `0` 이나 `1` 로 설정하더라도 시간이 조금씩 지나면서 연속된 값에 빈 공간이 생길 가능성이 높다. 그러므로 자동 증가 값이 반드시 연속이어야 한다는 요건에 너무 집착하지는 말자.

(참고) MySQL에서는 현재 커넥션에서 가장 마지막에 증가된 AUTO_INCREMENT 값을 조회할 수 있게 LAST_INSERT_ID() 함수를 제공한다. 현재 커넥션에서 가장 마지막으로 INSERT된 AUTO_INCREMENT 값만 반환한다.