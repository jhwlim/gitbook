---
description: Real MySQL 8.0
---

# 3. 실행 계획 분석

MySQL 8.0 버전부터는 EXPLAIN 명령의 결과로 출력되는 실행 계획의 포맷을 기존 테이블 포맷과 JSON, TREE 형태로 선택할 수 있다. 

아무런 옵션 없이 EXPLAIN 명령을 실행하면 쿼리 문장의 특성에 따라 표 형태로 된 1줄 이상의 결과가 표시된다. 표의 각 라인(레코드)은 쿼리 문장에서 사용된 테이블(임시 테이블 포함)의 개수 만큼 출력된다.

실행 순서는 위에서 아래로 순서대로 표시된다. (UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시되지 않을 수 있다.)

출력된 실행 계획에서 위쪽에 출력된 결과일수록 (id 칼럼의 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록(id 칼럼의 값이 클수록) 쿼리의 안쪽(Inner) 부분 또는 나중에 접근한 테이블에 해당한다.

## 1. id 칼럼

{% hint style="info" %}

**단위 쿼리**

SELECT 키워드 단위로 구분한 것

```sql
SELECT ...
FROM (SELECT ... FROM tb_test1) tb1, tb_test2 tb2
WHERE tb1.id = tb2.id
```

```sql
-- 단위 쿼리
SELECT ... FROM tb_test1;
SELECT ... FROM tb1, tb_test2 tb2 WHERE tb1.id = tb2.id;
```

{% endhint %}

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.

하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만, 같은 id 값이 부여된다.

```sql
-- 같은 id 값을 지닌 경우
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employee e, salaries s
WHERE e.emp_no = s.emp_no LIMIT 10;

-- 다른 id 값을 지닌 경우
EXPLAIN
SELECT
( (SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments) ) AS total_count;
```

{% hint style="warning" %}

실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지 않는다.

```sql
EXPLAIN FORMAT=TREE
SELECT * FROM dept_emp de
WHERE de.emp_no = (
    SELECT e.emp_no
    FROM employees e
    WHERE e.first_name = 'Georgi' AND e.last_name = 'Facello' 
    LIMIT 1
);
```

- employees 테이블이 가장 먼저 조회되고, 그 결과를 이용해 dept_emp 테이블을 조회

{% endhint %}

## 2. select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼

### (1) SIMPLE

UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 (쿼리에 조인이 포함된 경우 포함)

쿼리 문장이 아무리 복잡하더라도 실행 계획에서 select_type 이 SIMPLE 인 단위 쿼리는 하나만 존재한다.

일반적으로 제일 바깥 SELECT 쿼리의 select_tyep이 SIMPLE로 표시된다.

### (2) PRIMARY

UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리는 select_type이 PRIMARY로 표시된다.

select_type이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시된다.

### (3) UNION

UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫번째를 제외한 두번째 이후 단위 SELECT 쿼리의 select_type은 UNION으로 표시된다. UNION의 첫번째 단위 SELECT는 select_type이 UNION이 아니라 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type으로 표시된다.

### (4) DEPENDENT UNION

UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다.

DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.

예시

```sql
EXPLAIN
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
    SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
    UNION
    SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

- IN 내부의 서브쿼리를 먼저 처리하지 않고, 외부의 employees 테이블을 먼저 읽은 다음 서브쿼리를 실행하는데, 이때 employees 테이블의 칼럼값이 서브쿼리에 영향을 준다.
- 내부적으로는 UNION에 사용된 SELECT 쿼리에 WHERE 조건에 `e2.emp_no = e1.emp_no`와 `e3.emp_no = e1.emp_no` 라는 조건이 자동으로 추가되어 실행된다.
- 외부에 정의된 employees 테이블의 emp_no 칼럼이 서브쿼리에 사용되기 때문에 DEPENDENT UNION이 select_type에 표시된다. 

### (5) UNION RESULT

UNION 결과를 담아두는 테이블을 의미한다.

MySQL 8.0 이전 버전에서는 UNION ALL 이나 UNION(또는 UNION DISTINCT) 쿼리는 모두 UNION의 결과를 임시 테이블로 생성했는데, MySQL 8.0 버전부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다.

하지만 UNION(또는 UNION DISTINCT)은 MySQL 8.0 버전에서도 여저히 임시 테이블에 결과를 버퍼링한다. 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type이 UNION_RESULT 다. 

UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.

UNION ALL을 사용하면 MySQL 서버는 임시 테이블에 버퍼링하지 않기 때문에 UNION RESULT 라인이 필요치 않게 된다.

### (6) SUBQUERY

FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.

FROM 절에서 사용된 서브쿼리는 select_type이 DERIVED(파생 테이블)로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY라고 표시된다.

{% hint style="info" %}

서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 지니고 있다.

- **중첩된 쿼리**(Nested Query) : SELECT 되는 칼럼에 사용된 서브쿼리
- **서브쿼리**(Subquery) : WHERE 절에 사용되는 경우
- **파생 테이블**(Derived Table) : FROM 절에 사용된 서브쿼리, 일반적으로 RDBMS에서는 **인라인 뷰** 또는 **서브 셀렉트**라고 부른다.

서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분하기도 한다.

- **스칼라 서브쿼리**(Scalar Subquery) : 하나의 값만(칼럼이 단 하나인 레코드 1건만) 반환하는 쿼리
- **로우 서브쿼리**(Row Subquery) : 칼럼의 개수와 관계없이 하나읠 레코드만 반환하는 쿼리

{% endhint %}

### (7) DEPENDENT SUBQUERY

서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 칼럼을 사용하는 경우

예시

```sql
EXPLAIN
SELECT e.first_name,
    (
        SELECT COUNT(*)
        FROM dept_emp de, dept_manager dm
        WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no
    ) AS cnt
FROM employees e
WHERE e.first_name = 'Matt';
```

- 안쪽 서브쿼리의 결과가 바깥쪽 SELECT 쿼리의 칼럼에 의존적이기 때문에 DEPENDENT 라는 키워드가 붙는다.

외부 쿼리가 먼저 수행된 후 내부 쿼리(서브쿼리)가 실행돼야 하므로 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다.

### (8) DERIVED

MySQL 5.5 버전까지는 서브쿼리가 FROM 절에 사용된 경우 항상 select_type이 DERIVED인 실행 계획을 만든다. 파생 테이블에는 인덱스가 전혀 없으므로, 다른 테이블과 조인할 때 성능상 불리할 때가 많다.

하지만 MySQL 5.6 버전부터는 옵티마이저 옵션(optimizer_switch 시스템 변수)에 따라 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다. 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.

DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. select_type이 DERIVED인 경우에 생성되는 임시 테이블을 파생 테이블이라고도 한다.

파생 테이블에 대한 최적화가 부족한 버전의 MySQL 서버를 사용 중일 경우, 가능하다면 DERIVED 형태의 실행 계획을 조인으로 해결할 수 있게 쿼리를 바꿔주는 것이 좋다.

MySQL 8.0 버전부터는 FROM 절의 서브쿼리에 대한 최적화도 많이 개선되어 가능하다면 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리한다. 하지만 옵티마이저가 처리할 수 있는 것은 한계가 있으므로 여전히 최적화된 쿼리를 작성하는 것은 중요하다.

### (9) DEPENDENT DERIVED

DEPENDENT DERIVED 는 해당 테이블이 래터럴 조인으로 사용된 것을 의미한다.

MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 칼럼을 사용할 수가 없었는데, MySQL 8.0 버전부터는 래터럴 조인(LATERAL JOIN) 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 됐다.

예시

```sql
SELECT *
FROM employees e
LEFT JOIN LATERAL
    (
        SELECT *
        FROM salaries s
        WHERE s.emp_no = e.emp_no
        ORDER BY s.from_date DESC LIMIT 2
    ) AS s2
    ON s2.emp_no = e.emp_no;
```

래터럴 조인의 경우에는 LATERAL 키워드를 사용해야 하며, LATERAL 키워드가 없는 서브쿼리에서 외부 칼럼을 참조하면 오류가 발생한다.

### (10) UNCACHEABLE SUBQUERY

하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.

그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고, 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아준다. (여기서 언급하는 서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능)

캐시 사용하는 방법 비교 : SUBQUERY vs DEPENDENT SUBQUERY

- SUBQUERY : 바깥쪽(Outer)의 영향을 받지 않으므로, **처음 한번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.**
- DEPENDENT SUBQUERY : 의존하는 **바깥쪽(Outer) 쿼리의 칼럼의 값 단위로 캐시해두고 사용한다.**

SUBQUERY와 UNCACHEABLE SUBQUERY는 이 캐시를 사용할 수 있느냐 없느냐의 차이가 있다. 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능할 수가 있는데, 그럴 경우 select_type이 UNCACHEABLE SUBQUERY로 표시된다.

캐시를 사용하지 못하게 하는 요소

- 사용자 변수가 서브쿼리에 사용된 경우
- NOT-DETERMINISTIC  속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
- UUID()나 RAND()와 같은 결괏갑이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

### (11) UNCACHEABLE UNION

UNION과 UNCACHEABLE 이 두 개 키워드의 속성이 혼합된 select_type

### (12) MATERIALIZED

MySQL 5.6 버전부터 도입된 select_type

주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.

예시

```sql
-- 급여가 100보다 크거나 같고 1000보다 적거나 같은 직원들의 정보 조회
EXPLAIN
SELECT *
FROM employees e
WHERE e.emp_no IN (
    SELECT emp_no
    FROM salaries
    WHERE salary BETWEEN 100 AND 1000
);
```
- MySQL 5.6 버전까지는 employees 테이블을 읽어서 employees 테이블의 레코드마다 salaries 테이블을 읽는 서브쿼리가 실행되는 형태로 처리
- MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화(Materialization)한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.

DERIVED 와 비슷하게 쿼리의 내용을 임시 테이블로 생성한다는 것을 의마한다.

## 3. table 칼럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다. 

{% hint style="info" %}

별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우에는 table 칼럼에 NULL이 표시된다.

```sql
EXPLAIN SELECT NOW();
EXPLAIN SELECT NOW() FROM DUAL;
```

{% endhint %}

table 칼럼에 `<derived N>` 또는 `<union M,N>`과 같이 '<>'로 둘러싸인 이름이 명시되는 것은 임시 테이블을 의미한다. 또한 '<>" 안에 항상 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭한다.

실행 계획의 id 칼럼과 select_type, table 칼럼은 실행 계획의 각 라인에 명시된 테이블이 어떤 순서로 실행되는지를 판단하는 근거를 표시해준다.

MySQL 8.0 버전에서는 서브쿼리에 대한 최적화가 많이 보완됐는데, select_type 칼럼의 값이 MATERIALIZED 인 실행 계획에서는 `<subquery N>`과 같은 값이 table 칼럼에 표시된다. 이는 서브쿼리의 결과를 구체화(Materialization)해서 임시 테이블로 만들었다는 의미이며, 실제로는 `<derived N>`과 같은 방법으로 해석하면 된다.

## 4. partitions 칼럼

MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록은 EXPLAIN PARTITION 명령을 이용해서 확인 가능했지만, MySQL 8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 모두 확인할 수 있게 변경됐다.

파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 **파티션 프루닝**(Partition pruning)이라고 한다. 

```sql
CREATE TABLE employees_2 (
    emp_no int NOT NULL,
    birth_date DATE NOT NULL,
    first_name VARCHAR(14) NOT NULL,
    last_name VARCHAR(16) NOT NULL,
    gender ENUM('M', 'F') NOT NULL,
    hire_date DATE NOT NULL,
    PRIMARY KEY (emp_no, hire_date)
) PARTITION BY RANGE COLUMNS(hire_date)
(
    PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
    PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
    PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
    PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01')
);

EXPLAIN
SELECT *
FROM employees_2
WHERE hire_date BETWEEN '1999-11-15' AND '2000-01-15';
```
- type 칼러의 값이 ALL : MySQL을 포함한 대부분의 RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장공간을 가지기 때문에, employees_2 테이블의 모든 파티션이 아닌 p1966_2000 파티션과 p2001_2005 파티션만 풀 스캔을 실행하게 된다. 

## 5. type 칼럼

쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식(인덱스를 사용해 레코드를 읽었는지, 풀 테이블 스캔으로 읽었는지 등)로 읽었는지를 나타낸다. 

{% hint style="success" %}

일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로, 실행 계획에서 type 칼럼은 반드시 체크해야할 중요한 정보다.

{% endhint %}

{% hint style="info" %}

MySQL 매뉴얼에서는 type 칼럼을 '조인 타입'으로 소개하지만, 조인과 직접 연관지어 생각하지 말고, 각 테이블의 접근 방법으로 해석하면 된다.

{% endhint %}

type 칼럼에 표시될 수 있는 값 (성능이 빠른 순서)

- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subquery
- index_subquery
- range
- index_merge
- index
- ALL

위의 12개 접근 방법 중 `ALL`을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다. ALL은 인덱스를 사용하지 않고, 테이블을 처음부터 끝까지 읽어서 레코드를 가져오는 풀 테이블 스캔 접근 방법을 의미한다. 

하나의 단위 SELECT 쿼리는 위의 접근 방법 중에서 단 하나만 사용할 수 있다. 또한 index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다. 그러므로 실행 계획의 각 라인에 접근 방법이 2개 이상 표시되지 않으며, index_merge 이외에 type에서는 인덱스 항목에도 단 하나의 이름만 표시된다.

### (1) system

레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법

InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법

### (2) const

테이블의 레코드 건수와 관계없이 쿼리가 **프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절**을 가지고 있으며, **반드시 1건을 반환**하는 쿼리의 처리 방식

다른 DBMS에서는 이를 **유니크 인덱스 스캔**이라고도 표현한다.

다중 칼럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 칼럼만 조건으로 사용할 때는 const 타입의 접근 방법을 사용할 수 없다. 이 경우에는 실제 레코드가 1건만 저장돼 있더라도 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확실 할 수 없기 때문이다.

### (3) eq_ref

여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.

조인에서 처음 읽는 테이블의 칼럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때를 가리켜 eq_ref 라고 한다. 이때 두번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시된다. 또한 두번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL이어야 하며, 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용돼야만 사용될 수 있다. 즉, **조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법**이다.

### (4) ref

eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다.

ref 타입은 **반환되는 레코드가 반드시 1건이라는 보장이 없으므로** cosnt나 eq_ref보다는 빠르지 않다. 하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.

{% hint style="info" %}

동등 비교 연산자 : `=` 또는 `<=>`

`<=>` 연산자는 NULL에 대한 비교 방식만 조금 다를 뿐, `=` 연산자와 같은 연산자다.

{% endhint %}

### (5) fulltext

MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법

전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 한다.

MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높다.

전문 검색은 `MATCH (...) AGAINST (...)` 구문을 사용해서 실행하는데, 이때 반드시 해당 테이블에 전문 검색용 인덱스가 준비돼 있어야만 한다. 테이블에 전문 인덱스가 없다면 쿼리는 오류가 발생하고 중지될 것이다.

쿼리에 전문 검색 조건을 사용하면 MySQL 서버는 주저 없이 fulltext 접근 방법을 사용한다. 하지만 지금까지 저자의 경험으로 보면 전문 검색 인덱스를 이용하는 fulltext보다 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 더 많았다. 따라서 전문 검색 쿼리를 사용할 때는 조건별로 성능을 확인해 보는 편이 좋다.

### (6) ref_or_null

ref 접근 방법과 같은데, NULL 비교가 추가된 형태

실제 업무에서 많이 활용되지 않지만, 만약 사용된다면 나쁘지 않은 접근 방법 정도로 기억해 두면 충분한다.

### (7) unique_subquery

WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법

서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

### (8) index_subquery

IN 연산자의 특성상 IN(subquery) 또는 IN(상수) 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다.

그런데 IN(subquery)에서 subquery가 중복된 값을 반환할 수도 있다. 이때 **서브쿼리 결과의 중복된 값을 인덱스를 이용해 제거할 수 있을 때**, index_subquery 접근 방법이 사용된다.

### (9) range

인덱스 레인 스캔의 접근 방법

인덱스를 하나의 값이 아니라 범위로 검색하는 경우, 주로 `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.

일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법

얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.

{% hint style="info" %}

인덱스 레인지 스캔이라고 하면 보통 const, ref, range 접근 방법을 모두 묶어서 지칭한다.

일반적으로 인덱스 레인지 스캔 또는 레인지 스캔이라고 한다.

{% endhint %}

### (10) index_merge

2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식

특징

- 여러 인덱스를 읽어야 하므로, 일반적으로 range 접근 방법보다 효율성이 떨어진다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에, 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

### (11) index

인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다. (range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것이 아니다.)

풀 테이블 스캔 방식과 비교했을 때, 비교하는 레코드 건수는 같다. 하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 훨씬 효율적이라고 할 수 있다.

다음 조건 가운데 1번 조건과 2번 조건을 충족하거나, 1번 조건과 3번 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.

1. range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
2. 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)
3. 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (즉, 별도의 정렬 작업을 피할 수 있는 경우)

### (12) ALL

풀 테이블 스캔을 의미하는 접근 방법

테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거(체크 조건이 존재할 때)하고 반환한다.

데이터 웨어하우스나 배치 프로그램처럼 대용량의 레코드르 처리하는 쿼리에서는 잘못 튜닝된 쿼리(억지로 인덱스를 사용하게 튜닝된 쿼리)보다 더 나은 접근 방법이기도 하다. 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 사용하지 못하게 하는 것은 아니라는 점을 기억하자.

일반적으로 index나 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경에는 적합하지 않다. 테이블이 매우 작지 않다면 실제 테이블에 데이터를 어느 정도 저장한 상태에서 쿼리의 성능을 확인해 보고 적용하는 것이 좋다.

## 6. possible_keys 칼럼

옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용될 법했던 인덱스의 목록

실제로 실행 계획을 보면 그 테이블의 모든 인덱스가 목록에 포함되어 나오는 경우가 허다하기에 쿼리를 튜닝하는 데 크게 도움이 되지 않는다. 그래서 실행 계획을 확인할 때는 possible_keys 칼럼은 특별한 경우를 제외하고는 그냥 무시해도 된다.

## 7. key 칼럼

key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.

그러므로 쿼리르 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.

인덱스를 전혀 사용하지 못하면 key 칼럼은 NULL로 표시된다.

## 8. key_len 칼럼

쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다. 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려준다. 그래서 다중 칼럼 인덱스뿐 아니라 단일 칼럼으로 만들어진 인덱스에서도 같은 지표를 제공한다.

{% hint style="info" %}

NULLABLE 칼럼은 칼럼의 값이 NULL인지 아닌지를 저장하기 위해 1바이트를 추가로 더 사용한다.

{% endhint %}

## 9. ref 칼럼

참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다.

상수값을 지정했다면 ref 칼럼의 값은 const로 표시되고, 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다.

이 칼럼에 출력되는 내용은 크게 신경 쓰지 않아도 무방한데, ref 칼럼의 값이 func으로 표시된다면 주의해서 볼 필요가 있다. func은 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다. 사용자가 명시적으로 값을 변환할 때뿐만 아니라 MySQL 서버가 내부적으로 값을 변환해야 할 때도 ref 칼럼에는 func가 출력된다. 문자집합이 일치하지 않는 두 문자열 칼럼을 조인한다거나 숫자 타입의 칼럼과 문자열 타입의 칼럼으로 조인할 때가 대표적인 예다.

{% hint style="success" %}

가능하다면 MySQL 서버가 이런 변환을 하지 않아도 되게 조인 칼럼의 타입은 일치시키는 편이 좋다.

{% endhint %}

## 10. rows 칼럼

MySQL 실행 계획의 rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.

이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다. 또한, rows 칼럼에 표시되는 값은 반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미한다. 그래서 실행 계획의 rows 칼럼에 출력되는 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많다.

## 11. filtered 칼럼

filtered 칼럼의 값은 필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.

MySQL 서버 옵티마이저는 조인의 횟수를 줄이고 그 과정에서 읽어온 데이터를 저장해둘 메모리 사용량을 낮추기 위해 대상 건수가 적은 테이블을 선행 테이블로 선택할 가능성이 높다. 그래서 filtered 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라진다.

## 12. Extra 칼럼