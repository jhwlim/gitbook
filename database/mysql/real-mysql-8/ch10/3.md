---
description: Real MySQL 8.0
---

# 3. 실행 계획 분석

MySQL 8.0 버전부터는 EXPLAIN 명령의 결과로 출력되는 실행 계획의 포맷을 기존 테이블 포맷과 JSON, TREE 형태로 선택할 수 있다.

아무런 옵션 없이 EXPLAIN 명령을 실행하면 쿼리 문장의 특성에 따라 표 형태로 된 1줄 이상의 결과가 표시된다. 표의 각 라인(레코드)은 쿼리 문장에서 사용된 테이블(임시 테이블 포함)의 개수 만큼 출력된다.

실행 순서는 위에서 아래로 순서대로 표시된다. (UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시되지 않을 수 있다.)

출력된 실행 계획에서 위쪽에 출력된 결과일수록 (id 칼럼의 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록(id 칼럼의 값이 클수록) 쿼리의 안쪽(Inner) 부분 또는 나중에 접근한 테이블에 해당한다.

## 1. id 칼럼

{% hint style="info" %}

**단위 쿼리**

SELECT 키워드 단위로 구분한 것

```sql
SELECT ...
FROM (SELECT ... FROM tb_test1) tb1, tb_test2 tb2
WHERE tb1.id = tb2.id
```

```sql
-- 단위 쿼리
SELECT ... FROM tb_test1;
SELECT ... FROM tb1, tb_test2 tb2 WHERE tb1.id = tb2.id;
```

{% endhint %}

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.

하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만, 같은 id 값이 부여된다.

```sql
-- 같은 id 값을 지닌 경우
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employee e, salaries s
WHERE e.emp_no = s.emp_no LIMIT 10;

-- 다른 id 값을 지닌 경우
EXPLAIN
SELECT
( (SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments) ) AS total_count;
```

{% hint style="warning" %}

실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지 않는다.

```sql
EXPLAIN FORMAT=TREE
SELECT * FROM dept_emp de
WHERE de.emp_no = (
    SELECT e.emp_no
    FROM employees e
    WHERE e.first_name = 'Georgi' AND e.last_name = 'Facello'
    LIMIT 1
);
```

- employees 테이블이 가장 먼저 조회되고, 그 결과를 이용해 dept_emp 테이블을 조회

{% endhint %}

## 2. select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼

### (1) SIMPLE

UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 (쿼리에 조인이 포함된 경우 포함)

쿼리 문장이 아무리 복잡하더라도 실행 계획에서 select_type 이 SIMPLE 인 단위 쿼리는 하나만 존재한다.

일반적으로 제일 바깥 SELECT 쿼리의 select_tyep이 SIMPLE로 표시된다.

### (2) PRIMARY

UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리는 select_type이 PRIMARY로 표시된다.

select_type이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시된다.

### (3) UNION

UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫번째를 제외한 두번째 이후 단위 SELECT 쿼리의 select_type은 UNION으로 표시된다. UNION의 첫번째 단위 SELECT는 select_type이 UNION이 아니라 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type으로 표시된다.

### (4) DEPENDENT UNION

UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다.

DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.

예시

```sql
EXPLAIN
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
    SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
    UNION
    SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

- IN 내부의 서브쿼리를 먼저 처리하지 않고, 외부의 employees 테이블을 먼저 읽은 다음 서브쿼리를 실행하는데, 이때 employees 테이블의 칼럼값이 서브쿼리에 영향을 준다.
- 내부적으로는 UNION에 사용된 SELECT 쿼리에 WHERE 조건에 `e2.emp_no = e1.emp_no`와 `e3.emp_no = e1.emp_no` 라는 조건이 자동으로 추가되어 실행된다.
- 외부에 정의된 employees 테이블의 emp_no 칼럼이 서브쿼리에 사용되기 때문에 DEPENDENT UNION이 select_type에 표시된다.

### (5) UNION RESULT

UNION 결과를 담아두는 테이블을 의미한다.

MySQL 8.0 이전 버전에서는 UNION ALL 이나 UNION(또는 UNION DISTINCT) 쿼리는 모두 UNION의 결과를 임시 테이블로 생성했는데, MySQL 8.0 버전부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다.

하지만 UNION(또는 UNION DISTINCT)은 MySQL 8.0 버전에서도 여저히 임시 테이블에 결과를 버퍼링한다. 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type이 UNION_RESULT 다.

UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.

UNION ALL을 사용하면 MySQL 서버는 임시 테이블에 버퍼링하지 않기 때문에 UNION RESULT 라인이 필요치 않게 된다.

### (6) SUBQUERY

FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.

FROM 절에서 사용된 서브쿼리는 select_type이 DERIVED(파생 테이블)로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY라고 표시된다.

{% hint style="info" %}

서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 지니고 있다.

- **중첩된 쿼리**(Nested Query) : SELECT 되는 칼럼에 사용된 서브쿼리
- **서브쿼리**(Subquery) : WHERE 절에 사용되는 경우
- **파생 테이블**(Derived Table) : FROM 절에 사용된 서브쿼리, 일반적으로 RDBMS에서는 **인라인 뷰** 또는 **서브 셀렉트**라고 부른다.

서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분하기도 한다.

- **스칼라 서브쿼리**(Scalar Subquery) : 하나의 값만(칼럼이 단 하나인 레코드 1건만) 반환하는 쿼리
- **로우 서브쿼리**(Row Subquery) : 칼럼의 개수와 관계없이 하나읠 레코드만 반환하는 쿼리

{% endhint %}

### (7) DEPENDENT SUBQUERY

서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 칼럼을 사용하는 경우

예시

```sql
EXPLAIN
SELECT e.first_name,
    (
        SELECT COUNT(*)
        FROM dept_emp de, dept_manager dm
        WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no
    ) AS cnt
FROM employees e
WHERE e.first_name = 'Matt';
```

- 안쪽 서브쿼리의 결과가 바깥쪽 SELECT 쿼리의 칼럼에 의존적이기 때문에 DEPENDENT 라는 키워드가 붙는다.

외부 쿼리가 먼저 수행된 후 내부 쿼리(서브쿼리)가 실행돼야 하므로 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다.

### (8) DERIVED

MySQL 5.5 버전까지는 서브쿼리가 FROM 절에 사용된 경우 항상 select_type이 DERIVED인 실행 계획을 만든다. 파생 테이블에는 인덱스가 전혀 없으므로, 다른 테이블과 조인할 때 성능상 불리할 때가 많다.

하지만 MySQL 5.6 버전부터는 옵티마이저 옵션(optimizer_switch 시스템 변수)에 따라 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다. 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.

DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. select_type이 DERIVED인 경우에 생성되는 임시 테이블을 파생 테이블이라고도 한다.

파생 테이블에 대한 최적화가 부족한 버전의 MySQL 서버를 사용 중일 경우, 가능하다면 DERIVED 형태의 실행 계획을 조인으로 해결할 수 있게 쿼리를 바꿔주는 것이 좋다.

MySQL 8.0 버전부터는 FROM 절의 서브쿼리에 대한 최적화도 많이 개선되어 가능하다면 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리한다. 하지만 옵티마이저가 처리할 수 있는 것은 한계가 있으므로 여전히 최적화된 쿼리를 작성하는 것은 중요하다.

### (9) DEPENDENT DERIVED

DEPENDENT DERIVED 는 해당 테이블이 래터럴 조인으로 사용된 것을 의미한다.

MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 칼럼을 사용할 수가 없었는데, MySQL 8.0 버전부터는 래터럴 조인(LATERAL JOIN) 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 됐다.

예시

```sql
SELECT *
FROM employees e
LEFT JOIN LATERAL
    (
        SELECT *
        FROM salaries s
        WHERE s.emp_no = e.emp_no
        ORDER BY s.from_date DESC LIMIT 2
    ) AS s2
    ON s2.emp_no = e.emp_no;
```

래터럴 조인의 경우에는 LATERAL 키워드를 사용해야 하며, LATERAL 키워드가 없는 서브쿼리에서 외부 칼럼을 참조하면 오류가 발생한다.

### (10) UNCACHEABLE SUBQUERY

하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.

그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고, 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아준다. (여기서 언급하는 서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능)

캐시 사용하는 방법 비교 : SUBQUERY vs DEPENDENT SUBQUERY

- SUBQUERY : 바깥쪽(Outer)의 영향을 받지 않으므로, **처음 한번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.**
- DEPENDENT SUBQUERY : 의존하는 **바깥쪽(Outer) 쿼리의 칼럼의 값 단위로 캐시해두고 사용한다.**

SUBQUERY와 UNCACHEABLE SUBQUERY는 이 캐시를 사용할 수 있느냐 없느냐의 차이가 있다. 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능할 수가 있는데, 그럴 경우 select_type이 UNCACHEABLE SUBQUERY로 표시된다.

캐시를 사용하지 못하게 하는 요소

- 사용자 변수가 서브쿼리에 사용된 경우
- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
- UUID()나 RAND()와 같은 결괏갑이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

### (11) UNCACHEABLE UNION

UNION과 UNCACHEABLE 이 두 개 키워드의 속성이 혼합된 select_type

### (12) MATERIALIZED

MySQL 5.6 버전부터 도입된 select_type

주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.

예시

```sql
-- 급여가 100보다 크거나 같고 1000보다 적거나 같은 직원들의 정보 조회
EXPLAIN
SELECT *
FROM employees e
WHERE e.emp_no IN (
    SELECT emp_no
    FROM salaries
    WHERE salary BETWEEN 100 AND 1000
);
```

- MySQL 5.6 버전까지는 employees 테이블을 읽어서 employees 테이블의 레코드마다 salaries 테이블을 읽는 서브쿼리가 실행되는 형태로 처리
- MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화(Materialization)한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.

DERIVED 와 비슷하게 쿼리의 내용을 임시 테이블로 생성한다는 것을 의마한다.

## 3. table 칼럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.

{% hint style="info" %}

별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우에는 table 칼럼에 NULL이 표시된다.

```sql
EXPLAIN SELECT NOW();
EXPLAIN SELECT NOW() FROM DUAL;
```

{% endhint %}

table 칼럼에 `<derived N>` 또는 `<union M,N>`과 같이 '<>'로 둘러싸인 이름이 명시되는 것은 임시 테이블을 의미한다. 또한 '<>" 안에 항상 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭한다.

실행 계획의 id 칼럼과 select_type, table 칼럼은 실행 계획의 각 라인에 명시된 테이블이 어떤 순서로 실행되는지를 판단하는 근거를 표시해준다.

MySQL 8.0 버전에서는 서브쿼리에 대한 최적화가 많이 보완됐는데, select_type 칼럼의 값이 MATERIALIZED 인 실행 계획에서는 `<subquery N>`과 같은 값이 table 칼럼에 표시된다. 이는 서브쿼리의 결과를 구체화(Materialization)해서 임시 테이블로 만들었다는 의미이며, 실제로는 `<derived N>`과 같은 방법으로 해석하면 된다.

## 4. partitions 칼럼

MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록은 EXPLAIN PARTITION 명령을 이용해서 확인 가능했지만, MySQL 8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 모두 확인할 수 있게 변경됐다.

파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 **파티션 프루닝**(Partition pruning)이라고 한다.

```sql
CREATE TABLE employees_2 (
    emp_no int NOT NULL,
    birth_date DATE NOT NULL,
    first_name VARCHAR(14) NOT NULL,
    last_name VARCHAR(16) NOT NULL,
    gender ENUM('M', 'F') NOT NULL,
    hire_date DATE NOT NULL,
    PRIMARY KEY (emp_no, hire_date)
) PARTITION BY RANGE COLUMNS(hire_date)
(
    PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
    PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
    PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
    PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01')
);

EXPLAIN
SELECT *
FROM employees_2
WHERE hire_date BETWEEN '1999-11-15' AND '2000-01-15';
```

- type 칼러의 값이 ALL : MySQL을 포함한 대부분의 RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장공간을 가지기 때문에, employees_2 테이블의 모든 파티션이 아닌 p1966_2000 파티션과 p2001_2005 파티션만 풀 스캔을 실행하게 된다.

## 5. type 칼럼

쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식(인덱스를 사용해 레코드를 읽었는지, 풀 테이블 스캔으로 읽었는지 등)로 읽었는지를 나타낸다.

{% hint style="success" %}

일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로, 실행 계획에서 type 칼럼은 반드시 체크해야할 중요한 정보다.

{% endhint %}

{% hint style="info" %}

MySQL 매뉴얼에서는 type 칼럼을 '조인 타입'으로 소개하지만, 조인과 직접 연관지어 생각하지 말고, 각 테이블의 접근 방법으로 해석하면 된다.

{% endhint %}

type 칼럼에 표시될 수 있는 값 (성능이 빠른 순서)

- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subquery
- index_subquery
- range
- index_merge
- index
- ALL

위의 12개 접근 방법 중 `ALL`을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다. ALL은 인덱스를 사용하지 않고, 테이블을 처음부터 끝까지 읽어서 레코드를 가져오는 풀 테이블 스캔 접근 방법을 의미한다.

하나의 단위 SELECT 쿼리는 위의 접근 방법 중에서 단 하나만 사용할 수 있다. 또한 index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다. 그러므로 실행 계획의 각 라인에 접근 방법이 2개 이상 표시되지 않으며, index_merge 이외에 type에서는 인덱스 항목에도 단 하나의 이름만 표시된다.

### (1) system

레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법

InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법

### (2) const

테이블의 레코드 건수와 관계없이 쿼리가 **프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절**을 가지고 있으며, **반드시 1건을 반환**하는 쿼리의 처리 방식

다른 DBMS에서는 이를 **유니크 인덱스 스캔**이라고도 표현한다.

다중 칼럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 칼럼만 조건으로 사용할 때는 const 타입의 접근 방법을 사용할 수 없다. 이 경우에는 실제 레코드가 1건만 저장돼 있더라도 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확실 할 수 없기 때문이다.

### (3) eq_ref

여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.

조인에서 처음 읽는 테이블의 칼럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때를 가리켜 eq_ref 라고 한다. 이때 두번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시된다. 또한 두번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL이어야 하며, 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용돼야만 사용될 수 있다. 즉, **조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법**이다.

### (4) ref

eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다.

ref 타입은 **반환되는 레코드가 반드시 1건이라는 보장이 없으므로** cosnt나 eq_ref보다는 빠르지 않다. 하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.

{% hint style="info" %}

동등 비교 연산자 : `=` 또는 `<=>`

`<=>` 연산자는 NULL에 대한 비교 방식만 조금 다를 뿐, `=` 연산자와 같은 연산자다.

{% endhint %}

### (5) fulltext

MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법

전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 한다.

MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높다.

전문 검색은 `MATCH (...) AGAINST (...)` 구문을 사용해서 실행하는데, 이때 반드시 해당 테이블에 전문 검색용 인덱스가 준비돼 있어야만 한다. 테이블에 전문 인덱스가 없다면 쿼리는 오류가 발생하고 중지될 것이다.

쿼리에 전문 검색 조건을 사용하면 MySQL 서버는 주저 없이 fulltext 접근 방법을 사용한다. 하지만 지금까지 저자의 경험으로 보면 전문 검색 인덱스를 이용하는 fulltext보다 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 더 많았다. 따라서 전문 검색 쿼리를 사용할 때는 조건별로 성능을 확인해 보는 편이 좋다.

### (6) ref_or_null

ref 접근 방법과 같은데, NULL 비교가 추가된 형태

실제 업무에서 많이 활용되지 않지만, 만약 사용된다면 나쁘지 않은 접근 방법 정도로 기억해 두면 충분한다.

### (7) unique_subquery

WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법

서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

### (8) index_subquery

IN 연산자의 특성상 IN(subquery) 또는 IN(상수) 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다.

그런데 IN(subquery)에서 subquery가 중복된 값을 반환할 수도 있다. 이때 **서브쿼리 결과의 중복된 값을 인덱스를 이용해 제거할 수 있을 때**, index_subquery 접근 방법이 사용된다.

### (9) range

인덱스 레인 스캔의 접근 방법

인덱스를 하나의 값이 아니라 범위로 검색하는 경우, 주로 `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.

일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법

얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.

{% hint style="info" %}

인덱스 레인지 스캔이라고 하면 보통 const, ref, range 접근 방법을 모두 묶어서 지칭한다.

일반적으로 인덱스 레인지 스캔 또는 레인지 스캔이라고 한다.

{% endhint %}

### (10) index_merge

2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식

특징

- 여러 인덱스를 읽어야 하므로, 일반적으로 range 접근 방법보다 효율성이 떨어진다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에, 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

### (11) index

인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다. (range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것이 아니다.)

풀 테이블 스캔 방식과 비교했을 때, 비교하는 레코드 건수는 같다. 하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 훨씬 효율적이라고 할 수 있다.

다음 조건 가운데 1번 조건과 2번 조건을 충족하거나, 1번 조건과 3번 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.

1. range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
2. 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)
3. 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (즉, 별도의 정렬 작업을 피할 수 있는 경우)

### (12) ALL

풀 테이블 스캔을 의미하는 접근 방법

테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거(체크 조건이 존재할 때)하고 반환한다.

데이터 웨어하우스나 배치 프로그램처럼 대용량의 레코드르 처리하는 쿼리에서는 잘못 튜닝된 쿼리(억지로 인덱스를 사용하게 튜닝된 쿼리)보다 더 나은 접근 방법이기도 하다. 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 사용하지 못하게 하는 것은 아니라는 점을 기억하자.

일반적으로 index나 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경에는 적합하지 않다. 테이블이 매우 작지 않다면 실제 테이블에 데이터를 어느 정도 저장한 상태에서 쿼리의 성능을 확인해 보고 적용하는 것이 좋다.

## 6. possible_keys 칼럼

옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용될 법했던 인덱스의 목록

실제로 실행 계획을 보면 그 테이블의 모든 인덱스가 목록에 포함되어 나오는 경우가 허다하기에 쿼리를 튜닝하는 데 크게 도움이 되지 않는다. 그래서 실행 계획을 확인할 때는 possible_keys 칼럼은 특별한 경우를 제외하고는 그냥 무시해도 된다.

## 7. key 칼럼

key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.

그러므로 쿼리르 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.

인덱스를 전혀 사용하지 못하면 key 칼럼은 NULL로 표시된다.

## 8. key_len 칼럼

쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다. 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려준다. 그래서 다중 칼럼 인덱스뿐 아니라 단일 칼럼으로 만들어진 인덱스에서도 같은 지표를 제공한다.

{% hint style="info" %}

NULLABLE 칼럼은 칼럼의 값이 NULL인지 아닌지를 저장하기 위해 1바이트를 추가로 더 사용한다.

{% endhint %}

## 9. ref 칼럼

참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다.

상수값을 지정했다면 ref 칼럼의 값은 const로 표시되고, 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다.

이 칼럼에 출력되는 내용은 크게 신경 쓰지 않아도 무방한데, ref 칼럼의 값이 func으로 표시된다면 주의해서 볼 필요가 있다. func은 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다. 사용자가 명시적으로 값을 변환할 때뿐만 아니라 MySQL 서버가 내부적으로 값을 변환해야 할 때도 ref 칼럼에는 func가 출력된다. 문자집합이 일치하지 않는 두 문자열 칼럼을 조인한다거나 숫자 타입의 칼럼과 문자열 타입의 칼럼으로 조인할 때가 대표적인 예다.

{% hint style="success" %}

가능하다면 MySQL 서버가 이런 변환을 하지 않아도 되게 조인 칼럼의 타입은 일치시키는 편이 좋다.

{% endhint %}

## 10. rows 칼럼

MySQL 실행 계획의 rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.

이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다. 또한, rows 칼럼에 표시되는 값은 반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미한다. 그래서 실행 계획의 rows 칼럼에 출력되는 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많다.

## 11. filtered 칼럼

filtered 칼럼의 값은 필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.

MySQL 서버 옵티마이저는 조인의 횟수를 줄이고 그 과정에서 읽어온 데이터를 저장해둘 메모리 사용량을 낮추기 위해 대상 건수가 적은 테이블을 선행 테이블로 선택할 가능성이 높다. 그래서 filtered 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라진다.

## 12. Extra 칼럼

쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시된다.

Extra 칼럼에는 고정된 몇 개의 문장이 표시되는데, 일반적으로 2~3개씩 함께 표시된다.

Extra 칼럼에는 주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여주는 경우가 많다.

### (1) const row not found

쿼리 실행 계획에서 const 접근 방법으로 테이블을 읽었지만, 실제로 해당 테이블에 레코드에 레코드가 1건도 존재하지 않을 때 표시됨.

테이블에 적절히 테스트용 데이터를 저장하고 다시 한번 쿼리의 실행 계획을 확인해 보는 것이 좋다.

### (2) Deleting all rows

MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진 테이블인 경우 표시됨.

WHERE 조건절이 없는 DELETE 문장의 실행 계획에서 자주 표시되며, 이 문구는 테이블의 모든 레코드를 삭제하는 핸들러 기능(API)을 한번 호출함으로써 처리됐다는 것을 의미한다.

{% hint style="info" %}

기존에는 테이블의 모든 레코드를 삭제하기 위해 각 스토리지 엔진의 핸들러 함수를 레코드 건수만큼 호출해서 삭제해야 했는데, 'Deleting all rows' 처리 방식은 한 번의 핸들러 함수 호출로 아주 간단하고 빠르게 처리할 수 있다.

{% endhint %}

{% hint style="success" %}

MySQL 8.0 버전에서는 InnoDB 스토리지 엔진과 MyISAM 엔진 모두 더 이상 실행 계획에 'Deleting all rows' 최적화는 표시되지 않는다.

테이블의 모든 레코드를 삭제하고자 한다면 WHERE 조건절이 없는 DELETE 보다 TRUNCATE TABLE 명령을 사용할 것을 권장한다.

{% endhint %}

### (3) Distinct

쿼리의 DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인했으며, 꼭 필요한 레코드만 읽었다는 것을 표현

### (4) FirstMatch

세미 조인의 여러 최적화 중에서 FirstMatch 전략이 사용될 때 표시됨.

FirstMatch 메시지에 함께 표시되는 테이블은 기준 테이블을 의미한다.

### (5) Full scan on NULL key

`col1 IN (SELECT col2 FROM ...)`과 같은 조건을 가진 쿼리에서 자주 발생할 수 있는데, col1의 값이 NULL이 된다면 결과적으로 조건은 `NULL IN (SELECT col2 FROM ...)`과 같이 바뀐다.

SQL 표준에서는 NULL을 '알 수 없는 값'으로 정의하고 있으며, NULL에 대한 연산의 규칙까지 정의하고 있다. 그 정의대로 연산을 수행하기 위해 이 조건은 다음과 같이 비교돼야 한다.

- 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
- 서브쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE

이 비교 과정에서 col1이 NULL이면 서브쿼리에 사용된 테이블에 대해서 풀 테이블 스캔을 해야만 결과를 알아낼 수 있다. col1이 NOT NULL로 정의된 칼럼이라면 풀 테이블 스캔은 사용되지 않고, Extra 칼럼에도 표시되지 않을 것이다.

칼럼이 NOT NULL로 정의되지는 않았지만 이러한 NULL 비교 규칙을 무시해도 된다면, col1이 절대 NULL은 될 수 없다는 것을 MySQL 옵티마이저에게 알려주면 된다. 가장 대표적인 방법은 이 쿼리의 조건에 `col1 IS NOT NULL` 이라는 조건을 지정하면, `col1 IS NOT NULL` 조건이 FALSE가 되기 때문에 후속 조건인 `col1 IN (SELECT col2 FROM ...)` 조건은 실행하지 않는다.

Full scan on NULL key 코멘트가 표시됐다고 하더라도 IN이나 NOT IN 연산자의 왼쪽 값이 실제로 NULL이 없다면 풀 테이블 스캔은 발생하지 않으므로 걱정하지 않아도 된다.

하지만 IN이나 NOT IN 연산자의 왼쪽 값이 NULL인 레코드가 있고, 서브쿼리에 개별적으로 WHERE 조건이 지정돼 있다면 상당한 성능 문제가 발생할 수 있다.

### (6) Impossible HAVING

쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 표시됨.

애플리케이션의 쿼리 중에서 해당 메시지 출력된다면, 쿼리가 제대로 작성되지 못한 경우가 대부분이므로 쿼리의 내용을 다시 점검하는 것이 좋다.

### (7) Impossible WHERE

WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우 표시됨.

### (8) LooseScan

세미 조인 최적화 중에서 LooseScan 최적화 전략이 사용될 때 표시됨.

9.3.1.12. 루스 스캔 참조

### (9) No matching min/max row

쿼리의 WHERE 조건절을 만족하는 레코드가 한 건도 없는 경우, 일반적으로 표시됨.

MIN()이나 MAX()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 표시되고, MIN()이나 MAX()의 결과로 NULL이 반환된다.

{% hint style="warning" %}

'No matching ...' 이나 'Impossible WHERE ...' 등의 메시지는 쿼리 자체가 오류로 오해하기 쉬운데, Extra 칼럼에 출력되는 내용은 단지 쿼리의 실행 계획을 산출하기 위한 기초 자료가 없음을 표현하는 것 뿐이다.

실제 쿼리가 문법적으로 오류가 있는 것은 아니지만, 쿼리 처리를 위한 데이터가 없다는 의미이기 때문에 혹시 쿼리가 비즈니스적으로 잘못된 것인지 확인해볼 필요가 있다.

{% endhint %}

### (10) No matching row in const table

조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없다면 표시된다.

이 메시지 또한 'Impossible WHERE ...'와 같은 종류로, 실행 계획을 만들기 위한 기초 자료가 없음을 의미한다.

### (11) No matching rows after partition pruning

파티션된 테이블에 대한 UPDATE 또는 DELETE 명령의 실행 계획에서 표시될 수 있는데, 해당 파티션에서 UPDATE하거나 DELETE할 대상 레코드가 없을 때 표시된다.

단순히 삭제할 레코드가 없음을 의미하는 것이 아니라, 대상 파티션이 없다는 것을 의미한다.

### (12) No tables used

FROM 절이 없는 쿼리 문장이나 `FROM DUAL` 형태의 쿼리 실행 계획에서 표시된다. 다른 DBMS와는 달리 MySQL 서버는 FROM 절이 없는 쿼리도 허용된다.

FROM 절 자체가 없거나 FROM 절에 상수 테이블을 의미하는 DUAL(칼럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블)이 사용될 때 표시된다.

### (13) Not exists

아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서 표시된다.

테이블에 조인 조건에 일치하는 레코드가 여러 건이 있다고 하더라도 딱 1건만 조회해보고 처리를 완료하는 최적화를 의미한다.

{% hint style="info" %}

A 테이블에는 존재하지만, B 테이블에는 없는 값을 조회해야 하는 쿼리가 자주 사용된다. 이럴 때는 주로 NOT IN(subquery) 형태나 NOT EXISTS 연산자를 주로 사용한다. 이러한 형태의 조인을 **안티-조인**이라고 한다.

똑같은 처리를 아우터 조인(LEFT OUTER JOIN)을 이용해서도 구현할 수 있다.

{% endhint %}

일반적으로 NOT IN(subquery)이나 NOT EXISTS 등의 연산자를 사용하는 안티-조인으로 처리해야 하지만 레코드의 건수가 많을 때는 아우터 조인을 이용하면 빠른 성능을 낼 수 있다. 안티-조인은 일반 조인(INNER JOIN)을 했을 때 나오지 않는 결과만 가져오는 방법이다.

예시

```sql
EXPLAIN
SELECT *
FROM dept_emp de
    LEFT JOIN departments d ON de.dept_no = d.dept_no
WHERE d.dept_no IS NULL;
```

### (14) Plan isn't ready yet

MySQL 8.0 버전에서는 다른 커넥션에서 실행 중인 쿼리의 실행 계획을 살펴볼 수 있다.

```sql
--- 실제 커넥션 id(프로세스 번호)가 8인 커넥션에서 실행하고 있는 쿼리의 실행 계획 확인하기
EXPLAIN FOR CONNECTION 8;
```

`EXPLAIN FOR CONNECTION` 명령은 MySQL 옵티마이저가 의도된 인덱스를 사용하지 못해서 풀 스캔을 한다거나 잘못된 실행 계획을 선택한 것이 아닌지 확인할 때 유용하게 사용할 수 있는 명령이다.

'Plan is not ready yet' 메시지는 해당 커넥션에서 아직 쿼리의 실행 계획을 수립하지 못한 상태에서 EXPLAIN FOR CONNECTION 명령이 실행된 것을 의미한다.

이 경우에는 대상 커넥션의 쿼리가 실행 계획을 수립할 여유 시간을 좀 더 주고, 다시 EXPLAIN FOR CONNECTION 명령을 실행하면 된다.

### (15) Range checked for each record(index map: N)

레코드마다 인덱스 레인지 스캔을 체크할 때 표시된다.

'index map'에 표시된 후보 인덱스를 사용할지 여부를 검토해서 이 후보 인덱스가 별로 도움이 되지 않는다면 최종적으로 풀 테이블 스캔을 사용하는데, 이 때문에 type 칼럼에는 ALL로 표시된다.

각 레코드 단위로 이 후보 인덱스 가운데 어떤 인덱스를 사용할지 결정하게 되는데, 실제 어떤 인덱스가 사용됐는지는 알 수 없다.

예시

```sql
-- emp_no가 1번부터 1억번까지 있다고 가정
EXPLAIN
SELECT *
FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no;
```

- `e2.emp_no >= e1.emp_no` 조건을 만족하는 레코드를 찾아야 하는데, e1.emp_no=1 인 경우에는 e2 테이블의 1억 건 전부를 읽어야 하고, e1.emp_np=1000000000 인 경우에는 e2 테이블으 1건만 읽으면 된다.
- 그래서 e1 테이블의 emp_no가 작을 때는 e2 테이블을 풀 테이블 스캔으로 접근하고, e1 테이블의 emp_no가 큰 값일 때는 e2 테이블을 인덱스 레인지 스캔으로 접근하는 형태를 수행하는 것이 최적의 조인 방법이다.

### (16) Recursive

CTE(Common Table Expression)를 이용한 재귀 쿼리인 경우 표시된다. WITH 구문이 재귀 CTE로 사용될 경우에만 해당 메시지가 표시된다.

MySQL 8.0 버전부터는 CTE를 이용해 재귀를 작성할 수 있게 됐다. MySQL 서버에서 재귀 쿼리는 다음 예제와 같이 WITH 구문을 이용해 CTE를 사용하면 된다.

```sql
WITH RECURSIVE cte (n) AS
(
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM cte WHERE n < 5
)
SELECT * FROM cte;
```

- 'n' 이라는 칼럼 하나를 가진 cte라는 이름의 내부 임시 테이블을 생성
- 'n' 칼럼의 값이 1 부터 5 까지 1씩 증가하게 해서 레코드 5건을 만들어서 cte 내부 임시 테이블에 저장

그리고 WITH 절 다음의 SELECT 쿼리에서는 WITH 절에서 생성된 내부 임시 테이블을 (WHERE 절이 없으므로) 풀 스캔해서 결과를 반환한다.

### (17) Rematerialize

테이블마다 매번 임시 테이블이 새로 생성되는 경우 해당 문구가 표시된다.

{% hint style="info" %}

MySQL 8.0 버전부터는 래터럴 조인(LATERAL JOIN) 기능이 추가됐는데, 이 경우 래터럴로 조인되는 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시 테이블에 저장한다. 이 과정을 **Rematerializing**이라고 한다.

{% endhint %}

### (18) Select tables optimized away

MIN() 또는 MAX()만 SELECT 절에 사용되거나 GROUP BY로 MIN(), MAX()를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용된다는 해당 문구가 표시된다.

또한 MyISAM 테이블에 대해서는 GROUP BY 없이 COUNT(*)만 SELECT 할 때도 이런 형태의 최적화가 적용된다. MyISAM 테이블은 전체 레코드 건수를 별도로 관리하기 때문에 인덱스나 데이터를 읽지 않고도 전체 건수를 빠르게 조회할 수 있다. 하지만 MyISAM 테이블에서 WHERE 조건절이 있는 쿼리는 이런 최적화를 사용하지 못한다.

### (19) Start temporary, End temporary

세미 조인 최적화 중에서 Duplicate Weed-out 최적화 전략이 사용되면 'Start temporary'와 'End temporary' 문구가 표시된다.

Duplicated Weed-out 최적화 전략은 불필요한 중복 건을 제거하기 위해 내부 임시 테이블을 사용하는데, 이때 조인되어 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게 조인의 첫 번째 테이블에 'Start temporary' 문구가 표시되고, 조인이 끝나는 부분에 'End temporary' 문구가 표시된다.

9.3.1.14.중복 제거 참조

### (20) unique row not found

두 개의 테이블이 각각 유니크(프라이머리 키 포함) 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때, 해당 문구가 표시된다.

### (21) Using filesort

ORDER BY 처리가 인덱스를 사용하지 못할 때 해당 문구가 표시된다.

조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행하게 된다는 의미다.

ORDER BY가 사용된 쿼리의 실행 계획에만 나타날 수 있다.

{% hint style="success" %}

실행 계획에서 'Using filesort'가 출력되는 쿼리는 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.

{% endhint %}

### (22) Using index (커버링 인덱스)

데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때, 해당 문구가 표시된다.

인덱스만으로 처리되는 것을 **커버링 인덱스**라고 한다. 인덱스 레인지 스캔을 사용하지만 쿼리의 성능이 만족스럽지 못한 경우라면 인덱스에 있는 칼럼만 사용하도록 쿼리를 변경해 큰 성능 향상을 볼 수 있다.

하지만 무조건 커버링 인덱스로 처리하려고 인덱스에 많은 칼럼을 추가하면 더 위험한 상황이 초래될 수 있다. 너무 과도하게 인덱스의 칼럼이 많아지면 인덱스의 크기가 커져서 메모리 낭비가 심해지고, 레코드를 저장하거나 변경하는 작업이 매우 느려질 수 있기 때문이다.

접근 방법(실행 계획의 type 칼럼)이 eq_ref, ref, range, index_merge, index 등과 같이 인덱스를 사용하는 실행 계획에서는 모두 'Using index'가 표시될 수 있다. 인덱스 레인지 스캔을 사용할 때만 커버링 인덱스로 처리되는 것은 아니다. 인덱스 풀 스캔을 실행할 때도 커버링 인덱스로 처리될 수 있는데, 이때도 똑같은 인덱스 풀 스캔의 접근 방법이라면 커버링 인덱스가 아닌 경우보다 훨씬 빠르게 처리된다.

### (23) Using index condition

MySQL 옵티마이저가 인덱스 컨디션 푸시 다운 최적화를 사용하면 해당 문구가 표시된다.

9.3.1.3.인덱스 컨디션 푸시다운 참조

### (24) Using index for group-by

GROUP BY 처리를 위해 MySQL 서버는 그루핑 기준 칼럼을 이용해 정렬 작업을 수행하고, 다시 정렬된 결과를 그루핑하는 형태의 고부하 작업을 필요로 한다. 하지만 GROUP BY 처리가 인덱스를 이용하면 정렬된 인덱스 칼럼을 순서대로 읽으면서 그루핑 작업만 수행한다. 이렇게 GROUP BY 처리에 인덱스를 이용하면 상당히 효율적이고 빠르게 처리된다.

GROUP BY 처리가 인덱스를 이용할 때 쿼리의 실행 계획에서는 해당 문구가 표시된다.

GROUP BY 처리를 위해 인덱스를 읽는 방법을 **루스 인덱스 스캔**이라고 한다. (10.1.12.24.2.루스 인덱스 스캔을 통한 GROUP BY 처리 참조)

- **타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리** : AVG(), SUM(), COUNT() 처럼 조회하려는 값이 모든 인덱스를 다 읽어야할 때는 필요한 레코드만 듬성듬성 읽을 수가 없다. 루스 인덱스 스캔이라고 하지 않고, 이러한 퀀리의 실행 계획에는 해당 문구가 표시되지 않는다.
- **루스 인덱스 스캔을 통한 GROUP BY 처리** : 단일 칼럼으로 구성된 인덱스에서는 그루핑 칼럼 말고는 아무것도 조회하지 않는 쿼리에서 루스 인덱스 스캔을 사용할 수 있다. 그리고 다중 칼럼으로 만들어진 인덱스에서는 GROUP BY 절이 인덱스를 사용할 수 있어야 함은 물론이고, MIN()이나 MAX() 같이 조회하는 값이 인덱스의 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리는 루스 인덱스 스캔이 사용될 수 있다.

GROUP BY에서 인덱스를 사용하려면 우선 GROUP BY 조건에서 인덱스를 사용할 수 있는 요건이 갖춰져야 한다. 하지만 그 이전에 WHERE 절에서 사용하는 인덱스에 의해서도 GROUP BY 절의 인덱스 사용 여부가 영향을 받는다는 사실이 중요하다.


{% hint style="info" %}

WHERE 조건에 의해 검색된 레코드 건수가 적으면 루스 인덱스 스캔을 사용하지 않아도 매우 빠르게 처리될 수 있기 때문에, 루스 인덱스 스캔을 사용하지 않을 수 있다.

{% endhint %}

### (25) Using index for skip scan

MySQL 옵티마이저가 인덱스 스킵 스캔 최적화를 사용한다면 해당 문구가 표시된다.

8.3.4.4.인덱스 스킵 스캔 참조

### (26) Using join buffer

- Block Nested Loop
- Batched Key Access
- hash join

실제로 조인에 필요한 인덱스는 조인되는 양쪽 테이블 칼럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 칼럼에만 필요하다.

뒤에 읽는 테이블(드리븐 테이블)은 검색 위주로 사용되기 때문에 인덱스가 없으면 성능에 미치는 영향이 매우 크기 때문이다.

드리븐 테이블에 검색을 위한 적절한 인덱스가 없다면, MySQL 서버는 블록 네스티드 루프 조인이나 해시 조인을 사용한다. 블록 네스티드 루프 조인이나 해시 조인을 사용하면 MySQL 서버는 조인 버퍼를 사용한다. 실행 계획에서 조인 버퍼가 사용되는 실행 계획의 Extra 칼럼에는 'Using join buffer' 문구가 표시된다.

조인되는 칼럼에 인덱스가 적절하게 준비돼 있다면, 조인 버퍼는 크게 신경 쓰지 않아도 된다. 만약 그렇지 않다면 조인 버퍼를 너무 부족하거나 너무 과다하게 사용되지 않게 적절히 설정하는 것이 좋다. 일반적인 온라인 웹 서비스용 MySQL 서버라면 조인 버퍼 크기는 1MB 정도도 충분하다. 하지만 MySQL 8.0 버전부터는 해시 조인이 도입됐는데, 해시 조인 또한 조인 버퍼를 이용하도록 구현됐다. 그래서 데이터 웨어하우스처럼 대용량의 쿼리들을 실행해야 한다면 조인 버퍼를 더 크게 설정하는 것이 좋다.

### (27) Using MRR

MySQL 엔진은 실행 계획을 수립하고 그 실행 계획에 맞게 스토리지 엔진의 API를 호출해서 쿼리를 처리한다. 스토리지 엔진 레벨에서는 쿼리 실행의 전체적인 부분을 알지 못하기 때문에 최적화에 한계가 있다. 이러한 이유로 아무리 많은 레코드를 읽는 과정이라 하더라도 스토리지 엔진은 MySQL 엔진이 넘겨주는 키 값을 기준으로 레코드를 한 건 한 건 읽어서 반환하는 방식으로밖에 작동하지 못하는 한계점이 있다.

MySQL 서버는 이 같은 단점을 보완하기 위해 MRR(Multi Range Read)이라는 최적화를 도입했다. MySQL 엔진은 여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고, 스토리지 엔진은 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화한다. MRR이 도입되면서 각 스토리지 엔진은 디스크 접근을 최소화할 수 있게 된다.

9.3.1.1. MRR과 배치 키 액세스 참조

### (28) Using sort_union, Using union, Using intersect

쿼리가 index_merge 접근 방법으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있다. 이때, 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 조금 더 상세하게 설명하기 위해 다음 3개 중에서 하나의 메시지를 선택적으로 출력된다.

- Using intersect : 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우
- Using union : 각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우
- Using sort_union : Using union과 같은 작업을 수행하지만, Using usion으로 처리될 수 없는 경우 (OR로 연결된 상대적으로 대량의 range 조건들, 크다 & 작다와 같은 비교조건일 때)

'Using union'과 'Using sort_union'의 차이점 : Using sort_union은 프라이머리 키만 먼저 읽어서 정렬하고 병합한 이후 비로소 레코드를 읽어서 반환할 수 있다.

### (29) Using temporary

임시 테이블이 사용될 때 해당 문구가 출력된다.

이때, 사용된 임시 테이블이 메모리에 생성됐는지 디스크에 생성됐는지는 실행 계획만으로 판단할 수 없다.

또한, 'Using temporary'가 표시되지 않지만, 실제 내부적으로는 임시 테이블을 사용할 때도 많다.

- FROM 절에 사용된 서브 쿼리 (파생테이블)
- `COUNT(DISTINCT column1)`을 포함하는 쿼리 + 인덱스를 사용할 수 없는 경우
- UNION이나 UNION DISTINCT가 사용된 쿼리
- 인덱스를 사용하지 못하는 정렬 작업

### (30) Using where

MySQL 서버는 내부적으로 크게 MySQL 엔진과 스토리지 엔진이라는 두 개의 레이어로 나눌 수 있다. 각 스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할을 하며, MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행한다. MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리하는 경우에만 해당 문구가 표시된다.

'Using where' 문구는 흔히 표시되는 내용으로, 성능상의 문제를 일으킬지 아닐지를 적절히 선별하는 능력이 필요하다. MySQL 8.0에서는 실행 계획에 filtered 칼럼이 같이 표시되므로, 쉽게 성능상의 이슈가 있는지 없는지를 알아낼 수 있다.

### (31) Zero limit

LIMIT 0를 사용하는 경우 해당 문구가 표시된다.

MySQL 서버에서 쿼리 결과값의 메타데이터만 필요한 경우가 있다. 즉, 쿼리의 결과가 몇 개의 칼럼을 가지고, 각 컬럼의 타입은 무엇인지 등의 정보만 필요한 경우가 있다. 이런 경우에는 쿼리의 마지막에 `LIMIT 0`을 사용하면 되는데, 이때 MySQL 옵티마이저는 사용자의 의도(메타 정보만 조회하고자 하는 의도)를 알아채고, 실제 테이블의 레코드는 전혀 읽지 않고 결과값의 메타 정보만 반환한다.
