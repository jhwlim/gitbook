---
description: Real MySQL 8.0
---

# 3. 고급 최적화

MySQL 서버의 옵티마이저가 실행 계획을 수립할 때, 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립하게 된다.

옵티마이저의 옵션은 크게 조인 관련된 **옵티마이저 옵션**과 **옵티마이저 스위치**로 구분할 수 있다.

이들은 MySQL 서버의 고급 최적화 기능들을 활용할지를 제어하는 용도로 사용된다.

## 1. 옵티마이저 스위치 옵션

- `optimizer_switch` 시스템 변수를 이용해서 제어
- 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용
- 상세 옵티마이저 스위치 옵션은 p318~319 참고
- 각각의 옵티마이저 스위치 옵션은 `default`, `on`, `off` 중 하나를 설정
- 글로벌과 세션별 모두 설정할 수 있다.

  - MySQL 서버 전체적으로 또는 현재 커넥션에 대해서만 다음과 같이 설정할 수 있다.

  ```sql
  -- MySQL 서버 전체적으로 옵티마이저 스위치 설정
  SET GLOBAL optimizer_switch='index_merge=on,index_merge_union=on,...';

  -- 현재 커넥션의 옵티마이저 스위치만 설정
  SET SESSION optimizer_switch='index_merge=on,index_merge_union=on,...';
  ```

  - 현재 쿼리에만 설정할 수도 있다.

  ```sql
  SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */
  ...
  FROM ...
  ```

### (1) MRR과 배치 키 액세스(mmr & batched_key_access)

MRR은 Multi-Range Read, 매뉴얼에서는 DS-MRR(Disk Sweep Multi-Range Read)이라고도 한다.

MySQL 서버에서 지금까지 지원하던 조인 방식은 드라이빙 드라이빙 테이블(조인에서 제일 먼저 읽는 테이블)의 레코드를 한 건 읽어서 드리븐 테이블(조인되는 테이블에서 드라이빙이 아닌 테이블들)의 일치하는 레코드를 찾아서 조인을 수행하는 것이 었다. 이를 **네스티드 루프 조인(Nested Loop Join)** 이라고 한다.

MySQL 서버의 내부 구조상 조인 처리는 MySQL 엔진이 처리하지만, 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다. 이때 드라이빙 테이블의 레코드 건별로 드리븐 테이블의 레코드를 찾으면 레코드를 찾고 읽는 스토리지 엔진에서는 아무런 최적화를 수행할 수 없다.

이와 같은 단점을 보완하기 위해 MySQL 서버는 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인 버퍼에 버퍼링한다. 조인 버퍼에 레코드가 가득 차면 비로소 MyQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다. 이렇게 함으로써 스토리지 엔진은 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있는 것이다.

이러한 읽기 방식을 **MRR**(Multi-Range Read)이라고 한다.

{% hint style="info" %}

**BKA(Batched Key Access) 조인**

- MRR을 응용해서 실행되는 조인 방식
- BKA 조인을 사용하게 되면 부가적인 정렬 작업이 필요해지면서 성능에 안 좋은 영향을 미치는 경우도 있기 때문에 BKA 조인 최적화는 기본적으로 비활성화돼 있다.

{% endhint %}

### (2) 블록 네스티드 루프 조인(block_nested_loop)

**네스티드 루프 조인**

- MySQL 서버에서 사용되는 대부분의 조인
- 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 방식
- 프로그래밍 언어에서 마치 중첩된 반복 명령을 사용하는 것처럼 작동
- 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고, 즉시 드리븐 테이블의 레코드를 찾아서 반환한다.

예시

```sql
SELECT *
FROM employees e
    INNER JOIN salaries s ON s.emp_no=e.emp_no
        AND s.from_date <= NOW()
        AND s.to_date >= NOW()
WHERE e.first_name = 'Amor';
```

```
// 의사코드
for (row1 IN employees) {
    for (row2 IN salaries) {
        if (condition_matched) {
            return (row1, row2)
        }
    }
}
```

네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 **조인 버퍼(join_buffer_size 시스템 설정으로 조정되는 조인을 위한 버퍼)가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐**다.

{% hint style="info" %}

조인에서 Block 이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐다는 것을 의미한다.

조인 쿼리의 실행 계획에서 Extra 컬럼에 "Using Join buffer"라는 문구가 표시되면 조인 버퍼를 사용한다는 것을 의미한다.

{% endhint %}

조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다. 즉, 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블은 여러 번 읽는다는 것을 의미한다. 그래서 드리븐 테이블을 검색할 때, 인덱스를 사용할 수 없는 쿼리는 상당히 느려지며, 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.

그런데 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다. 이때 사용하는 메모리의 캐시를 **조인 버퍼**라고 한다. 조인 버퍼는 `join_buffer_size`라는 시스템 변수로 크기를 제한할 수 있으며, 조인이 완료되면 조인 버퍼는 바로 해제된다.

조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행된다. 실제 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.

{% hint style="warning" %}

일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만, **조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다.**

{% endhint %}

{% hint style="info" %}

MySQL 8.0.18 버전부터는 **해시 조인 알고리즘**이 도입됐으며, MySQL 8.0.20 버전부터는 **블록 네스티드 루프 조인**은 더 이상 사용되지 않고, 해시 조인 알고리즘이 대체되어 사용된다.

{% endhint %}

### (3) 인덱스 컨디션 푸시다운(index_condition_pushdown)

MySQL 5.6 버전부터 도입

{% hint style="info" %}

"Using where"는 InnoDB 스토리지 엔진이 읽어서 반환해준 레코드가 인덱스를 사용할 수 없는 WHERE 조건이 일치하는지 검사하는 과정을 의미한다.

{% endhint %}

인덱스를 비교하는 작업은 실제 InnoDB 스토리지 엔진이 수행하지만, 테이블의 레코드에서 조건을 비교하는 작업은 MySQL 엔진이 수행한다. MySQL 5.5 버전까지는 인덱스를 범위 제한 조건으로 사용하지 못하는 조건은 MySQl 엔진이 스토리지 엔진으로 아예 전달해주지 않았다. → 스토리지 엔진에서 불필요한 읽기가 추가로 발생

**MySQL 5.6 버전부터는 인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도, 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달**할 수 있게 핸들러 API가 개선됨. (Extra 컬럼에 "Using condition"이 표시됨.)

```sql
-- ix_lastname_firstname (last_name, first_name)
SELECT *
FROM employees
WHERE last_name = 'Action' 
    AND first_name LIKE '%sal';
```

- MySQL 5.5 버전까지는 `LIKE '%sal'` 조건을 처리하기 위해 인덱스 사용 X (풀 스캔 필요)

인덱스 컨디션 푸시다운 기능은 쿼리의 성능을 몇 배에서 몇십 배로 향상될 수도 있는 중요한 기능이다.

### (4) 인덱스 확장 (use_index_extensions)

### (5) 인덱스 머지 (index_merge)

### (6) 인덱스 머지 - 교집합 (index_merge_intersection)

### (7) 인덱스 머지 - 합집합 (index_merge_union)

### (8) 인덱스 머지 - 정률 후 교집합 (index_merge_sort_union)

### (9) 세미 조인 (semijoin)

### (10) 테이블 풀-아웃 (Table Pull-out)

### (11) 퍼스트 매치 (firstmatch)

### (12) 루스 스캔 (loosescan)

### (13) 구체화 (Materialization)

### (14) 중복 제거 (Duplicated Weed-out)

### (15) 컨디션 팬아웃 (condition_fanout_filter)

### (16) 파생 테이블 머지 (derived_merge)

### (17) 인비저블 인덱스 (use_invisible_indexes)

### (18) 스킵 스캔 (skip_scan)

### (19) 해시 조인 (hash_join)

### (20) 인덱스 정렬 선호 (prefer_ordering_index)

## 2. 조인 최적화 알고리즘
