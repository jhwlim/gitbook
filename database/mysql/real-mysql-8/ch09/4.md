---
description: Real MySQL 8.0
---

# 4. 쿼리 힌트

서비스 개발자나 DBA보다 MySQL 서버가 부족한 실행 계획을 수립할 때가 있을 수도 있다. 이런 경우에는 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줄 수 있는 방법이 필요하다. 일반적으로 RDBMS에서는 이런 목적으로 힌트가 제공되며, MySQL에서도 다양한 옵티마이저 힌트를 제공한다.

MySQL 서버에서 사용 가능한 쿼리 힌트는 다음과 같이 2가지로 구분할 수 있다.

- 인덱스 힌트 : "USE INDEX" (예전 버전의 MySQL 서버에서 사용되어 오던 힌트)
- 옵티마이저 힌트 : MySQL 5.6 버전부터 새롭게 추가되기 시작한 힌트

## 1. 인덱스 힌트

- "STRAIGHT_JOIN"과 "USE INDEX" 등을 포함한 인덱스 힌트들은 모두 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용
- ANSI-SQL 표준 문법을 준수하지 못하게 되는 단점이 있다.

{% hint style="success" %}

MySQL 5.6 버전부터 추가되기 시작한 옵티마이저 힌트들은 모두 MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석하기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있다.

그래서 **가능하다면 인덱스 힌트보다는 옵티마이저 힌트를 사용할 것을 추천한다.**

{% endhint %}

### (1) STRAIGHT_JOIN

- 옵티마이저 힌트인 동시에 조인 키워드이기도 하다.
- SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.
- 일반적으로 조인을 하기 위한 칼럼들의 인덱스 여부로 조인의 순서가 결정되며, 조인 칼럼의 인덱스에 아무런 문제가 없는 경우에는 레코드가 적은 테이블을 드라이빙으로 선택한다.
- **STRAIGHT_JOIN 힌트는 옵티마이저가 FROM절에 명시된 테이블의 순서대로 조인을 수행하도록 유도한다.**
- 주로 다음 기준에 맞게 조인 순서가 결정되지 않은 경우에만 STRAIGHT_JOIN 힌트로 조인 순서를 조정하는 것이 좋다.
  - 임시 테이블(인라인 뷰 또는 파생된 테이블)과 일반 테이블의 조인
    - 거의 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다.
  - 임시 테이블끼리 조인
    - 임시 테이블(서브쿼리로 파생된 테이블)은 크기가 작은 테이블을 드라이빙 테이블로 선택해주는 것이 좋다.
  - 일반 테이블끼리 조인
    - 양쪽 테이블 모두 조인 칼럼에 인덱스가 있거나 양쪽 테이블 모두 조인 칼럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택해주는 것이 좋다.
    - 그 이외의 경우에는 조인 칼럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋다.
- STRAIGHT_JOIN 키워드가 SELECT 키워드 바로 뒤에 사용됐다는 것에 주의하자.

```sql
SELECT STRAIGHT_JOIN
    e.first_name, e.last_name. d.dept_name
FROM
    employees e, dept_emp de, departments d
WHERE
    e.emp_no = de.emp_no
    AND d.dept_no = de.dept_no;

SELECT /*! STRAIGHT_JOIN */
    e.first_name, e.last_name, d.dept_name
FROM
    employees e, dept_emp de, departments d
WHERE
    e.emp_no = de.emp_no
    AND d.dept_no = de.dept_no;
```

{% hint style="warning" %}

인덱스 힌트는 사용해야 하는 위치가 이미 결정됐으므로 그 이외의 다른 위치에서는 사용하지 않도록 주의하자.

{% endhint %}

- STRAIGHT_JOIN 힌트와 비슷한 역할을 하는 옵티마이저 힌트 : JOIN_FIXED_ORDER, JOIN_ORDER, JOIN_PREFIX, JOIN_SUFFIX
  - JOIN_FIXED_ORDER : STRAIGHT_JOIN 힌트와 동일한 효과
  - JOIN_ORDER, JOIN_PREFIX, JOIN_SUFFIX : 일부 테이블의 조인 순서에 대해서만 제안하는 힌트 (vs. STRAIGHT_JOIN은 FROM절의 모든 테이블에 대해 조인 순서를 결정)

### (2) USE INDEX / FORCE INDEX / IGNORE INDEX

- 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.
- 대체로 MySQL 옵티마이저는 어떤 인덱스를 사용해야 할지를 무난하게 잘 선택하는 편이지만, 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 존재하는 경우에는 가끔 옵티마이저가 실수를 하는데, 이런 경우에는 강제로 특정 인덱스를 사용하도록 힌트를 추가한다.
- 키워드 뒤에 사용할 인덱스의 이름을 괄호로 묶어서 사용하며, 괄호 안에 아무것도 없거나 존재하지 않는 인덱스 이름을 사용할 경우에는 쿼리의 문법 오류로 처리된다.
- 또한 별도로 사용자가 부여한 이름이 없는 프라이머리 키는 "PRIMARY"라고 명시하면 된다.

- USE INDEX
  - 가장 자주 사용되는 인덱스 힌트
  - MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장
  - 항상 해당 인덱스를 사용하는 것은 아니다.
- FORCE INDEX
  - USE INDEX 보다 옵티마이저에게 미치는 영향이 더 강한 힌트
  - 필자의 경험상 대체로 USE INDEX 힌트를 부여해도 해당 인덱스를 사용하지 않는 경우라면 FORCE INDEX 힌트를 사용해도 해당 인덱스를 사용하지 않았다. → 거의 사용 X
- IGNORE INDEX
  - 특정 인덱스를 사용하지 못하게 하는 용도로 사용
  - 풀 테이블 스캔을 사용하도록 유도하기 위해 사용할 수도 있다.

위의 3종류의 인덱스 힌트 모두 용도를 명시해 줄 수 있다. (optional)

- USE INDEX **FOR JOIN** : 테이블 간의 조인뿐만 아니라 레코드를 검색하기 위한 용도까지 포함하는 용어
- USE INDEX **FOR ORDER BY** : 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있게 제한한다.
- USE INDEX **FOR GROUP BY** : 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한한다.

{% hint style="success" %}

용도를 3가지로 나누긴 했지만 ORDER BY나 GROUP BY 작업에서 인덱스를 사용할 수 있다면 나은 성능을 보장하며, 용도는 옵티마이저가 대부분 최적으로 선택하기 때문에 인덱스의 용도까지는 크게 고려하지 않아도 된다.

{% endhint %}

전문 검색 인덱스가 있는 경우에는 MySQL 옵티마이저는 다른 일반 보조 인덱스(B-Tree 인덱스)를 사용할 수 있는 상황이라고 하더라도 전문 검색 인덱스를 선택하는 경우가 많다. 옵티마이저는 프라이머리 키나 전문 검색 인덱스와 같은 인덱스에 대해서는 선택시 가중치를 두고 실행 계획을 수립하기 때문이다.

{% hint style="success" %}

인덱스의 사용법이나 좋은 실행 계획이 어떤 것인지 판단하기 힘든 상황이라면 힌트를 사용해 강제로 옵티마이저의 실행 계획에 영향을 미치는 것은 피하는 것이 좋다.

최적의 실행 계획은 데이터의 성격에 따라서 시시각각 변하므로, 가능하다면 그때그때 옵티마이저가 당시 통계 정보를 가지고 선택하게 하는 것이 가장 좋다.

가장 훌륭한 최적화는 그 쿼리를 서비스에서 없애버리거나 튜닝할 필요가 없게 데이터를 최소화하는 것이며, 그것이 어렵다면 데이터 모델의 단순화를 통해 쿼리를 간결하게 만들고 힌트가 필요치 않게 하는 것이다.

{% endhint %}

### (3) SQL_CALC_FOUND_ROWS

MySQL의 LIMIT을 사용하는 경우, 조건을 만족하는 레코드가 LIMIT에 명시된 수보다 더 많다고 하더라도 LIMIT에 명시된 수만큼 만족하는 레코드를 찾으면 즉시 검색 작업을 멈춘다.

하지만 SQL_CALC_FOUND_ROWS 힌트가 포함된 쿼리의 경우에는 LIMIT을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행한다.

SQL_CALC_FOUND_ROWS 힌트가 사용된 쿼리가 실행된 경우에는 FOUND_ROW()라는 함수를 이용해 LIMIT을 제외한 조건을 만족하는 레코드가 전체 몇 건이었는지를 알아낼 수 있다.

```sql
SELECT SQL_CALC_FOUND_ROWS * FROM employees LIMIT 5;

SELECT FOUND_ROWS() AS total_record_count;
```

**이 힌트를 사용하면 안되는 경우**

```sql
-- (1) SQL_CALC_FOUND_ROWS 를 사용하는 방법
SELECT SQL_CALC_FOUND_ROWS * FROM employees WHERE first_name = 'Georgi' LIMIT 0, 20;
SELECT FOUND_ROWS() AS total_record_count;

-- (2) 기존 2개의 쿼리로 쪼개어 실행하는 방법
SELECT COUNT(*) FROM employees WHERE first_name = 'Georgi';

SELECT * FROM employees WHERE first_name = 'Georgi' LIMIT 0, 20;
```
- (1) 쿼리 2회 실행, 전체 레코드의 수 만큼 랜덤 I/O 발생
- (2) 쿼리 2회 실행, LIMIT 0, 20 제한이 있기 때문에 20회 랜덤 I/O 발생

(1)은 (2)에 비해 디스크 작업 횟수가 많기 때문에 느리다.

또한 SELECT 쿼리 문장이 UNION(또는 UNION DISTINCT)으로 연결된 경우에는 SQL_CALC_FOUND_ROWS 힌트를 사용해도 FOUND_ROWS() 함수로 정확한 레코드를 가져올 수 없다.

{% hint style="success" %}

인덱스나 쿼리 튜닝이 제대로 됐다면 후자 방식이 SQL_CALC_FOUND_ROWS를 사용하는 방식보다는 빠르게 실행될 것이므로, SQL_CALC_FOUND_ROWS는 사용하지 않는 방향으로 추천한다.

{% endhint %}

## 2. 옵티마이저 힌트

### (1) 옵티마이저 힌트 종류

영향 범위에 따라 다음 4개의 그룹으로 나누어 볼 수 있다.

- 인덱스 : 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 옵션
- 테이블 : 특정 테이블의 이름을 사용할 수 있는 옵티마이저 옵션
- 쿼리 블록 : 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트, 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
- 글로벌(쿼리 전체) : 전체 쿼리에 대해서 영향을 미치는 힌트

이 구분으로 인해 힌트의 사용 위치가 달라지는 것은 아니다. 

{% hint style="warning" %}

모든 인덱스 수준의 힌트는 반드시 테이블명이 선행돼야 한다.

```sql
EXPLAIN
SELECT /*+ INDEX(employees ix_firstname) */ *
FROM employees
WHERE first_name='Matt';

EXPLAIN
SELECT /*+ NO_INDEX(employees ix_firstname) */ *
FROM employees
WHERE first_name='Matt';
```

만약 옵티마이저 힌트가 문법에 맞지 않게 잘못 사용된 경우에는 경고 메시지가 표시된다. 익숙하지 않은 힌트를 사용할 경우에는 EXPLAIN 명령으로 힌트 문법상 오류가 있지 않은지 확인하자.

{% endhint %}

하나의 SQL 문장에서 SELECT 키워드는 여러 번 사용될 수 있다. 이때 각 SELECT 키워드로 시작하는 서브쿼리 영역을 **쿼리 블록**이라고 한다. 특정 쿼리 블록에 영향을 미치는 옵티마이저 힌트는 그 쿼리 블록 내에서 사용될 수도 있지만, 외부 쿼리 블록에서 사용할 수도 있다. 이처럼 **특정 쿼리 블록을 외부 쿼리 블록에서 사용하려면 "QB_NAME()" 힌트를 이용해 해당 쿼리 블록에 이름을 부여해야 한다.**

```sql
EXPLAIN
SELECT /*+ JOIN_ORDER(e, s@subq1) */
    COUNT(*)
FROM 
    employees e
WHERE
    e.first_name = 'Matt'
    AND e.emp_no IN (
        SELECT /*+ QB_NAME(subq1) */ 
            s.emp_no
        FROM
            salaries s
        WHERE
            s.salary BETWEEN 50000 AND 50500
    )
```

### (2) MAX_EXECUTION_TIME

- 옵티마이저 힌트 중에서 유일하게 쿼리의 실행 계획에 영향을 미치지 않는 힌트
- 단순히 쿼리의 최대 실행 시간을 설정하는 힌트
- 밀리초 단위의 시간을 설정하는데, 쿼리가 지정된 시간을 초과하면 쿼리는 실패하게 된다.

### (3) SET_VAR

- 다양한 형태의 시스템 변수 조정 가능
- 실행 계획을 바꾸는 용도뿐만 아니라 조인 버퍼나 정렬용 버퍼(소트 버퍼)의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도로 사용할 수 있다.
- 모든 시스템 변수를 조정할 수는 없다.

### (4) SEMIJOIN & NO_SEMIJOIN

- 어떤 세부 전략을 사용할지를 제어하는데 사용
- 최적화 전략 : Duplicate Weed-out, First Match, Loose Scan, Materialization, Table Pull-out(설정 X)
- 외부 쿼리가 아닌 서브 쿼리에 명시해야 한다.
- 다른 방법으로는 우선 서브쿼리에 쿼리 블록 이름을 정의하고 실제 세미 조인 힌트는 외부 쿼리 블록에 명시하는 방법이 있다.
- 특정 세미 조인 최적화 전략을 사용하지 않게 하려면 NO_SEMIJOIN 힌트를 명시해서, 해당 최적화 전략을 사용하지 않게 가이드한다.

### (5) SUBQUERY

- 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법
- 최적화 방법 : IN-to-EXISTS, Materialization
- 세미 조인 최적화는 주로 IN(subquery) 형태의 쿼리에 사용될 수 있지만, 안티 세미 조인의 최적화에는 사용될 수 없다.
- 그래서 주로 안티 세미 조인 최적화에는 위의 2가지 최적화가 사용된다.
- 서브쿼리에 힌트를 사용하거나 서브쿼리에 쿼리 블록 이름을 지정해서 외부 쿼리 블록에 최적화 방법을 명시하면 된다.

### (6) BNL & NO_BNL & HASHJOIN & NO_HASHJOIN

- MySQL 8.0.20 버전과 그 이후 버전에서는 BNL 힌트를 사용하면 해시 조인을 사용하도록 유도하는 힌트로 용도가 변경 됐다. (원래는 블록 네스티드 루프 조인 알고리즘)
- HASHJOIN과 NO_HASHJOIN 힌트는 MySQL 8.0.18 버전에서만 유효하며, 그 이후 버전에서는 효력이 없다. 그래서 MySQL 8.0.20과 그 이후 버전에서는 해시 조인을 유도하거나 해시 조인을 사용하지 않게 하고자 한다면 BNL과 NO_BNL 힌트를 사용해야 한다.

### (7) JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX

- 조인의 순서를 결정하기 위해 전통적으로 STRAIGHT_JOIN 힌트를 사용해왔는데, 쿼리의 FROM 절에 사용된 테이블의 순서를 조인 순서에 맞게 변경해야 하는 번거로움이 있다. 또한, 한번 사용되면 FROM 절에 명시된 모든 테이블의 조인 순서가 결정되기 때문에 일부는 조인 순서를 강제하고 나머지는 옵티마이저에게 순서를 결정하게 맞기는 것이 불가능했다.
- 이러한 단점을 보완하게 위해 다음과 같은 4개 힌트를 제공한다.
    - JOIN_FIXED_ORDER : FROM 절의 테이블 순서대로 조인을 실행 (STRAIGHT_JOIN 힌트와 동일)
    - JOIN_ORDER : 힌트에 명시된 테이블의 순서대로 조인을 실행
    - JOIN_PREFIX : 조인에서 드라이빙 테이블만 강제
    - JOIN_SUFFIX : 조인에서 드리븐 테이블 (가장 마지막에 조인돼야 할 테이블들)만 강제

### (8) MERGE & NO_MERGE

예전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리를 항상 내부 임시 테이블(파생 테이블, Derived table)로 생성했다. 이는 불필요한 자원 소모를 유발한다. 그래서 MySQL 5.7과 8.0 버전에서는 가능하면 임시 테이블을 사용하지 않게 FROM 절의 서브쿼리르 외부 쿼리와 병합하는 최적화를 도입했다. 때로는 MySQL 옵티마이저가 내부 쿼리를 외부 쿼리와 병합하는 것이 나을 수도 있고, 때로는 내부 임시 테이블을 생성하는 것이 더 나은 선택일 수도 있다. 하지만 MySQL 옵티마이저는 최적의 방법을 선택하지 못할 수도 있는데, 이때는 MERGE 또는 NO_MERGE 옵티마이저 힌트를 사용하면 된다.

### (9) INDEX_MERGE & NO_INDEX_MERGE

하나의 테이블에 대해 여러 개의 인덱스를 동시에 사용되는 것을 **인덱스 머지**라고 한다. 인덱스 머지 실행 계획은 때로는 성능 향상에 도움이 되지만, 항상 그렇지는 않을 수도 있다. 인덱스 머지 실행 계획의 사용 여부를 제어하고자 할 때, INDEX_MERGE와 NO_INDEX_MERGE 옵티마이저 힌트를 이용하면 된다.

### (10) NO_ICP

**인덱스 컨디션 푸시다운**(ICP, Index Condition Pushdown) 최적화는 사용 가능하다면 항상 성능 향상에 도움이 되므로, MySQL 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행 계획을 수립한다. 그래서 MySQL 옵티마이저에서는 ICP 힌트는 제공되지 않는다. 그런데 인덱스 컨디션 푸시다운으로 인해 여러 실행 계획의 비용 계산이 잘못된다면 결과적으로 잘못된 실행 계획을 수립하게 될 수도 있다.

예를 들어 A 인덱스와 B 인덱스가 있다고 할 때, A 인덱스에서는 인덱스 컨디션 푸시 다운이 가능해서 A 인덱스를 사용하는 것이 비용이 낮게 예측됐다. 하지만 실제 서비스에서는 B 인덱스를 선택하는 것이 더 효율적일 수도 있다. 이러한 경우 A 인덱스를 완전히 사용하지 못하게 하거나, B 인덱스를 선호하게 하는 것은 좋지 않은 선택일 수도 있다. 테이블의 데이터 분포는 항상 균등한 것이 아니기 때문에 쿼리 검색 범위에 따라 A 인덱스 또는 B 인덱스가 효율적일 수 있기 때문이다. 이와 같은 경우에는 인덱스 컨디션 푸시다운 최적화만 비활성화해서 조금 더 유연하고 정확하게 실행 계획을 선택하게 할 수 있다.

### (11) SKIP_SCAN & NO_SKIP_SCAN

인덱스의 선행 칼럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 기능

하지만 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 성능은 오히려 더 떨어진다. MySQL 옵티마이저가 유니크한 값의 개수를 제대로 분석하지 못하거나 잘못된 경로로 인해 비효율적인 인덱스 스킵 스캔을 선택하면, NO_SKIP_SCAN 옵티마이저 힌트를 이용해 인덱스 스킵 스캔을 사용하지 않게 할 수 있다.

### (12) INDEX & NO_INDEX

예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공된다.

옵티마이저 힌트에는 테이블명과 인덱스 이름을 함께 명시해야 한다. (vs 인덱스 힌트는 특정 테이블 뒤에 사용했기 때문에 별도로 힌트내에 테이블명 없이 인덱스 이름만 나열함.)
