---
description: Real MySQL 8.0
---

# 2. 기본 데이터 처리

MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다.

## 1. 풀 테이블 스캔과 풀 인덱스 스캔

### 풀 테이블 스캔

인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업

**다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.**

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

일반적으로 <u>테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다.</u> 그래서 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다. 하지만 MySQL에는 풀 테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이즈를 읽어올지 설정하는 시스템 변수가 없다. 그래서 MyISAM 스토리지 엔진에서는 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어온다.

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 실행된다. 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드(클라이언트 스레드)가 페이지 읽기를 실행하지만, <u>특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.</u> 백그라운드 스레드가 읽기를 넘겨받은 시점부터는 한 번에 여러 개의 페이지를 읽어서 버퍼 풀에 저장해둔다. 따라서 <u>포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리된다.</u>

{% hint style="info" %}

**리드 어헤드**

어떤 영역의 데이터가 앞으로 필요해지라는 것을 예측해서 요청이 오기 전에 미리 데이터에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.

`innodb_read_ahead_threshold` 시스템 변수를 이용해 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다. 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재한다.

{% endhint %}

{% hint style="success" %}

리드 어헤드 설정은 일반적으로 디폴트 설정으로도 충분하지만, 데이터 웨어하우스용으로 MySQL을 사용한다면 더 낮은 값으로 설정해서 더 빨리 리드 어헤드가 시작되게 유도하는 것도 좋은 방법이다.

{% endhint %}

### 풀 인덱스 스캔

인덱스를 처음부터 끝까지 스캔하는 것

일반적으로 인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능하다.

리드 어헤드가 사용된다.

## 2. 병렬 처리

{% hint style="info" %}

**병렬 처리**

**하나의 쿼리**를 여러 스레드가 작업을 나눠서 동시에 처리하는 것

{% endhint %}

MySQL 8.0 에서는 `innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할지 설정할 수 있다.

<u>병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간은 줄어든다.</u>

{% hint style="warning" %}

병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있다.

{% endhint %}

## 3. ORDER BY 처리 (Using filesort)

정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 'Filesort'라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

|-|장점|단점|
|:-:||:--|:--|
|인덱스 이용|INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼어 있음. → 순서대로 읽기만 하면되기 때문에 매우 빠르다.|INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하다.<br>인덱스 때문에 디스크 공간이 더 많이 필요하다.<br>인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요하다.|
|Filesort 이용|인덱스 생성 X → 인덱스를 이용할 때의 단점이 장점이 된다.<br>정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort로 처리되므로 충분히 빠르다.|레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.|

**아래와 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기 어렵다.**

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

<u>MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extrea 칼럼에 "Using filesort' 메서지가 표시되는지 여부로 판단할 수 있다.</u>

### (1) 소트 버퍼

### (2) 정렬 알고리즘

- 싱글 패스 정렬 방식
- 투 패스 정렬 방식

### (3) 정렬 처리 방법

- 인덱스를 이용한 정렬
- 조인의 드라이빙 테이블만 정렬
- 임시 테이블을 이용한 정렬
- 정렬 처리 방법의 성능 비교

### (4) 정렬 관련 상태 변수

## 4. GROUP BY 처리

### (1) 인덱스 스캔을 이용한 GROUP BY (타이트 인덱스 스캔)

### (2) 루스 인덱스 스캔을 이용하는 GROUP BY

### (3) 임시 테이블을 사용하는 GROUP BY

## 5. DISTINCT 처리

### (1) SELECT DISTINCT ...

### (2) 집합 함수와 함께 사용된 DISTINCT

## 6. 내부 임시 테이블 활용

### (1) 메모리 임시 테이블과 디스크 임시 테이블

### (2) 임시 테이블이 필요한 쿼리

### (3) 임시 테이블이 디스크에 생성되는 경우

### (4) 임시 테이블 관련 상태 변수
