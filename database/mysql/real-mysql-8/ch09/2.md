---
description: Real MySQL 8.0
---

# 2. 기본 데이터 처리

MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다.

## 1. 풀 테이블 스캔과 풀 인덱스 스캔

### 풀 테이블 스캔

인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업

**다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.**

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

일반적으로 <u>테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다.</u> 그래서 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다. 하지만 MySQL에는 풀 테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이즈를 읽어올지 설정하는 시스템 변수가 없다. 그래서 MyISAM 스토리지 엔진에서는 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어온다.

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 실행된다. 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드(클라이언트 스레드)가 페이지 읽기를 실행하지만, <u>특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.</u> 백그라운드 스레드가 읽기를 넘겨받은 시점부터는 한 번에 여러 개의 페이지를 읽어서 버퍼 풀에 저장해둔다. 따라서 <u>포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리된다.</u>

{% hint style="info" %}

**리드 어헤드**

어떤 영역의 데이터가 앞으로 필요해지라는 것을 예측해서 요청이 오기 전에 미리 데이터에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.

`innodb_read_ahead_threshold` 시스템 변수를 이용해 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다. 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재한다.

{% endhint %}

{% hint style="success" %}

리드 어헤드 설정은 일반적으로 디폴트 설정으로도 충분하지만, 데이터 웨어하우스용으로 MySQL을 사용한다면 더 낮은 값으로 설정해서 더 빨리 리드 어헤드가 시작되게 유도하는 것도 좋은 방법이다.

{% endhint %}

### 풀 인덱스 스캔

인덱스를 처음부터 끝까지 스캔하는 것

일반적으로 인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능하다.

리드 어헤드가 사용된다.

## 2. 병렬 처리

{% hint style="info" %}

**병렬 처리**

**하나의 쿼리**를 여러 스레드가 작업을 나눠서 동시에 처리하는 것

{% endhint %}

MySQL 8.0 에서는 `innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할지 설정할 수 있다.

<u>병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간은 줄어든다.</u>

{% hint style="warning" %}

병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있다.

{% endhint %}

## 3. ORDER BY 처리 (Using filesort)

정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 'Filesort'라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

|                 | 장점                                                                                                                                           | 단점                                                                                                                                                                                                      |
| :-------------: | :--------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   인덱스 이용   | • INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼어 있음. → 순서대로 읽기만 하면되기 때문에 매우 빠르다.                          | • INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하다.<br>• 인덱스 때문에 디스크 공간이 더 많이 필요하다.<br>• 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요하다. |
| • Filesort 이용 | 인덱스 생성 X → 인덱스를 이용할 때의 단점이 장점이 된다.<br>• 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort로 처리되므로 충분히 빠르다. | • 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.                                                                                                                                                |

**아래와 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기 어렵다.**

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

<u>MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extrea 칼럼에 "Using filesort" 메서지가 표시되는지 여부로 판단할 수 있다.</u>

### (1) 소트 버퍼

- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는 메모리 공간
- 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가
- 최대 사용 가능한 소트버퍼의 공간은 `sort_buffer_size` 시스템 변수 설정 가능
- 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납됨.

{% hint style="info" %}

🤔 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면?

정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.

{% endhint %}

- 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔다. 그리고 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장한다. 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 하는 병합 작업을 **멀티 머지**라고 표현한다.
- 수행된 멀티 머지 횟수는 `Sort_merge_passes`라는 상태 변수에 누적해서 집계된다. (`SHOW STATUS VARIABLES` 명령 참조)
- 이 작업들은 모두 디스크의 쓰기와 읽기를 유발하며, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아진다.

{% hint style="warning" %}

`sort_buffer_size` 시스템 변수의 설정값이 크면 메모리에서 모두 처리되니 빨라질 것으로 예상할 수 있지만, 실제 결과는 그렇지 않다. 리눅스 계열의 운영체제에서는 `sort_buffer_size`가 너무 크면, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수도 있다.

{% endhint %}

{% hint style="success" %}

저자의 경험상 일반적인 트랜잭션 처리용 MySQL 서버의 소트 버퍼 크기는 56KB ~ 1MB 미만이 적절하다고 함.

{% endhint %}

- 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다. 따라서 커넥션이 많으면 많을수록, 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커진다.
- 소트 버퍼의 크기를 10MB 이상으로 설정하면 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면서 운영체제는 메모리 부족 현상을 겪을 수 있다. (이때, 운영체제의 OOM-Killer가 여유 메모리를 확보하기 위해서 프로세스를 강제로 종료할 것이며, 일반적으로 메모리를 가장 많이 사용하는 프로세스인 MySQL 서버를 강제 종료한다.)

{% hint style="success" %}

소트 버퍼를 크게 설정해서 빠른 성능을 얻을 수는 없지만 디스크의 읽기와 쓰기 사용량을 줄일 수 있다. 그래서 MySQL 서버의 데이터가 많거나 디스크의 I/O 성능이 낮은 장비라면 소트 버퍼의 크기를 더 크게 설정하는 것이 도움이 될 수도 있다. (너무 크게 설정하면 서버의 메모리 부족 현상을 겪을 수 있기 때문에 적절히 설정 필요)

대량 데이터의 정렬이 필요한 경우 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리를 실행하고 다시 줄이는 것도 좋은 방법이다.

{% endhint %}

### (2) 정렬 알고리즘

레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 **싱글 패스**와 **투 패스** 2가지 정렬 모드로 나룰 수 있다.
정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능으로 확인할 수 있다.

```sql
-- 옵티마이저 트레이스 활성화
SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

-- 쿼리 실행
SELECT * FROM employees ORDER BY last_name LIMIT 100000,1;

-- 트레이스 내용 확인
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G;
```

- `filesort_summary.sort_algorithm` : 정렬 알고리즘
- `filesort_summary.sort_mode` : MySQL 정렬 방식
  - `<sort_key, rowid>` : 정렬 키와 레코드 Row ID만 가져와서 정렬하는 방식 (투 패스 정렬 방식)
  - `<sort_key, additional_fields>` : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 고정 사이즈로 메모리 저장 (싱글 패스 정렬 방식)
  - `<sort_key, packed_additional_fields>` : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 가변 사이즈로 메모리 저장 (싱글 패스 정렬 방식, MySQL 5.7 버전부터 도입, 정렬을 위한 메모리 공간의 효율적인 사용을 위해 추가됨.)

**싱글 패스 정렬 방식**

- 소트 버퍼에 정렬 기준 칼럼을 전부 담아서 정렬을 수행하는 정렬 방식
- 더 많은 소트 버퍼 공간 필요
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용
- 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보임.

**투 패스 정렬 방식**

- 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식
- 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식
- 테이블을 2번 읽어야 하기 때문에 싱글 패스와 비교해서 불합리함.
- MySQL 8.0에서도 여전히 특정 조건에서 사용됨.
  - 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
  - BLOB 이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때
- 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적

{% hint style="success" %}

SELECT 쿼리에서 모든 칼럼(`*`)을 가져오도록 하면, 정렬 버퍼를 몇 배에서 몇십 배까지 비효율적으로 사용할 가능성이 크다. 이러한 이유로 **정렬이 필요한 SELECT는 불필요한 칼럼을 SELECT하지 않게 쿼리를 작성하는 것이 효율적이다.** 이는 임시 테이블이 필요한 쿼리에서도 영향을 미친다.

{% endhint %}

### (3) 정렬 처리 방법

쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리된다. 일반적으로 아래쪽에 있는 정렬 방법으로 갈수록 처리 속도는 떨어진다.

| 정렬 처리 방법                                  | 실행 계획의 Extra 칼럼 내용     |
| :---------------------------------------------- | :------------------------------ |
| 인덱스를 사용한 정렬                            | 별도 표기 없음                  |
| 조인에서 드라이빙 테이블만 정렬                 | Using filesort                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | Using temporary; Using filesort |

**정렬 처리 방법**

1. 먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토한다. 인덱스를 사용할 수 있다면 별도의 "Filesort" 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다.
2. 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)한다. 이때, MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 2가지 방법 중 하나를 선택한다.
   - 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
   - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행 : 조인이 수행되면서 레코드의 건수와 레코드의 크기가 거의 배수로 늘어나기 때문에 비효율적

**방법1. 인덱스를 이용한 정렬**
**방법2. 조인의 드라이빙 테이블만 정렬**
**방법3. 임시 테이블을 이용한 정렬**
**정렬 처리 방법의 성능 비교**

### (4) 정렬 관련 상태 변수

## 4. GROUP BY 처리

### (1) 인덱스 스캔을 이용한 GROUP BY (타이트 인덱스 스캔)

### (2) 루스 인덱스 스캔을 이용하는 GROUP BY

### (3) 임시 테이블을 사용하는 GROUP BY

## 5. DISTINCT 처리

### (1) SELECT DISTINCT ...

### (2) 집합 함수와 함께 사용된 DISTINCT

## 6. 내부 임시 테이블 활용

### (1) 메모리 임시 테이블과 디스크 임시 테이블

### (2) 임시 테이블이 필요한 쿼리

### (3) 임시 테이블이 디스크에 생성되는 경우

### (4) 임시 테이블 관련 상태 변수
