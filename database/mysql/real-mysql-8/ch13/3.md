---
description: Real MySQL 8.0
---

# 3. MySQL 파티션의 종류

## 1. 레인지 파티션

- 파티션 키의 연속된 범위로 파티션을 정의하는 방법
- 가장 일반적으로 사용되는 파티션 방법 중 하나
- 다른 파티션 방법과는 달리 MAXVALUE 키워드를 이용해 명시되지 않은 범위의 키 값이 담긴 레코드를 저장하는 파티션을 정의할 수 있다.

### (1) 레인지 파티션의 용도

- 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때

장점

- 큰 테이블을 작은 크기의 파티션으로 분리
- 필요한 파티션만 접근 (쓰기와 읽기 모두)

위의 2가지 장점 중 첫 번째보다는 두 번째 장점의 효과가 매우 큰 편인데, 첫 번째 장점에만 집중하다 보니 결과적으로 파티션 때문에 오히려 MySQL 서버의 성능을 더 떨어뜨리게 될 수 있다.

이력을 저장하는 테이블에서 레인지 파티션은 두 가지 장점을 모두 어렵지 않게 취할 수 있다.

### (2) 레인지 파티션 레이블 생성

예시

```sql
CREATE TABLE employees (
    id INT NOT NULL,
    first_name VARCHAR(30),
    last_name VARCHAR(30),
    hired DATE NOY NULL DEFAULT '1970-01-01',
    ...
) PARTITION BY RANGE( YEAR(hired) ) (
  PARTITION p0 VALUES LESS THAN (1991),
  PARTITION p1 VALUES LESS THAN (1996),
  PARTITION p2 VALUES LESS THAN (2001),
  PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

- p0 : 입사일자가 1990년 이하
- p1 : 입사일자가 1991년부터 1995년 이하
- p2 : 입사일자가 1996년부터 2000년 이하
- p3 : 입사일자가 2001년 이후

### (3) 레인지 파티션의 분리와 병합

#### 1. 단순 파티션의 추가

주의사항

하나의 레코드는 반드시 하나의 파티션에만 저장돼야 하기 때문에 기존의 파티션이 존재하는 상황에서 새로운 파티션을 추가하기 위해서는 `ALTER TABLE ... REORGANIZE PARTITION` 명령을 사용해야 한다.

```sql
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
  REORGANIZE PARTITION p3 INTO (
    PARTITION p3 VALUES LESS THAN (2011),
    PARTITION p4 VALUES LESS THAN MAXVALUE
  );
```

`ALTER TABLE ... REORGANIZE PARTITION` 명령은 파티션의 레코드를 모두 새로운 두 개의 파티션으로 복사하는 작업을 필요로 한다. 이때 기존의 파티션의 레코드가 매우 많다면 이 작업은 매우 오랜 시간이 걸릴 것이다.

`LESS THAN MAXVALUE` 파티션이 존재한다고 하더라도 이 파티션의 데이터를 가지고 있지 않다면 매우 빨리 완료될 것이므로 성능 관련해서 걱정하지 않아도 된다. 따라서 MAXVALUE 파티션을 추가할지 말지는 INSERT되는 데이터의 특성이나 배치 스크립트의 안정성에 따라 적절히 판단하면 된다.

#### 2. 파티션 삭제

`DROP PARTITION` 명령 사용

레인지 파티션을 삭제하는 작업이나 리스트 파티션 테이블에서 특정 파티션을 삭제하는 작업은 아주 빠르게 처리된다.

→ 날짜 단위로 파티션된 테이블에서 오래된 데이터를 삭제하는 용도로 자주 사용된다.

```sql
ALTER TABLE employees DROP PARTITION p0;
```

{% hint style="info" %}

레인지 파티션을 사용하는 테이블에서 파티션을 삭제할 때 항상 가장 오래된 파티션 순서로만 삭제할 수 있다.

{% endhint %}

{% hint style="info" %}

레인지 파티션을 사용하는 테이블에서는 가장 마지막 파티션만 새로 추가할 수 있고, 가장 오래된 파티션만 삭제할 수 있다.

{% endhint %}

#### 3. 기존 파티션의 분리

`REORGANIZE PARTITION` 명령 사용

```sql
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
  REORGANIZE PARTITION p3 INTO (
    PARTITION p3 VALUES LESS THAN (2011),
    PARTITION p4 VALUES LESS THAN MAXVALUE
  );
```

기존 파티션의 레코드를 새로운 파티션으로 복사해야 하기 때문에 기존 파티션의 레코드 건수에 따라 시간이 오래 걸릴 수도 있다.

{% hint style="success" %}

기존 파티션의 레코드가 많다면 온라인 DDL로 실행할 수 있게 ALGORITHM과 LOCK 절을 사용하자.

하지만 파티션을 재구성하는 작업은 INPLACE 알고리즘을 사용할 수 있지만, 최소한 읽기 잠금이 필요하다. 즉, 파티션이 재구성되는 동안 테이블의 쓰기가 불가능해지므로, 파티션 재구성 작업은 서비스 점검 시간대나 쿼리 처리가 많지 않은 시간대에 진행하는 것이 좋다.

{% endhint %}

#### 4. 기존 파티션의 병합

`REORGANIZE PARTITION` 명령 사용

```sql
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
  REORGANIZE PARTITION p2, p3 INTO (
    PARTITION p23 VALUES LESS THAN (2011)
  );
```

{% hint style="warning" %}

파티션을 병합하는 경우에도 파티션 재구성이 필요하며, 이 작업은 테이블에 대해서 읽기 잠금을 필요로 하기 때문에 주의해야 한다.

{% endhint %}

## 2. 리스트 파티션

- 레인지 파티션과 흡사하게 동작
- 레인지 파티션과의 차이점
  - 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다. (레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있다.)
  - 리스트 파티션은 MAXVALUE 파티션을 정의할 수 없다.

### (1) 리스트 파티션의 용도

- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고, 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고, 검색 조건에 파티션 키가 자주 사용될 때

### (2) 리스트 파티션 테이블 생성

예시

```sql
CREATE TABLE product(
  id INT NOT NULL,
  name VARCHAR(30),
  category_id INT NOT NULL,
  ...
) PARTITION BY LIST( category_id ) (
  PARTITION p_appliance VALUES IN (3),
  PARTITION p_computer VALUES IN (1, 9),
  PARTITION p_sports VALUES IN (2, 6, 7),
  PARTITION p_etc VALUES IN (4, 5, 8, NULL)
);
```

- 파티션을 정의할 때, `VALUES IN`을 사용한다.

### (3) 리스트 파티션의 분리와 병합

파티션을 정의하는 부분에서 `VALUES IN`을 사용한다는 것 외에는 레인지 파티션의 추가 및 삭제, 병합 작업은 모두 같다.

특정 파티션의 레코드 건수가 많아져서 두 개 이상의 파티션으로 분리하거나 그 반대로 병합하려면 `REORANIZE PARTITION` 명령을 사용하면 된다.

### (4) 리스트 파티션 주의사항

- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없다.
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있다.

## 3. 해시 파티션

- MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법
- MySQL에서 정의한 해시 함수는 파티션 표현식의 결과값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정하는 방식
- 파티션 키는 항상 정수 타입의 칼럼이거나 정술늘 반환하는 표현식만 사용될 수 있다.
- 파티션의 개수는 레코드를 각 파티션에 할당하는 알고리즘과 연관되기 때문에 파티션을 추가하거나 삭제하는 작업에는 테이블 전체적으로 레코드를 재분배하는 작업이 따른다.

### (1) 해시 파티션의 용도

테이블의 데이터가 특정 칼럼의 값에 영향을 받지 않고, 전체적으로 비슷한 사용 빈도를 보일 때 적합한 파티션 방법

- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때

### (2) 해시 파티션 테이블 생성

```sql
-- 파티션의 개수만 지정할 때
CREATE TABLE employees (
  id INT NOT NULL,
  first_name VARCHAR(30),
  last_name VARCHAR(30),
  hired DATE NOT NULL DEFAULT '1970-01-01',
  ...
) PARTITION  BY HASH(id) PARTITIONS 4;

-- 파티션의 이름을 별도로 지정하고자 할 때
CREATE TABLE employees (
  id INT NOT NULL,
  first_name VARCHAR(30),
  last_name VARCHAR(30),
  hired DATE NOT NULL DEFAULT '1970-01-01',
  ...
) PARTITION BY HASH(id)
  PARTITIONS 4 (
    PARTITION p0 ENGINE=INNODB,
    PARTITION p1 ENGINE=INNODB,
    PARTITION p2 ENGINE=INNODB,
    PARTITION p3 ENGINE=INNODB
  );
```

### (3) 해시 파티션의 분리와 병합

해시 파티션의 분리와 병합은 대상 테이블의 모든 파티션에 저장된 레코드를 재분배하는 작업이 필요하다.

파티션의 분리나 병합으로 인해 파티션의 개수가 변경된다는 것은 해시 함수의 알고리즘을 변경하는 것이므로 전체 파티션이 영향을 받는다.

#### 1. 해시 파티션 추가

해시 파티션은 특정 파티션 키 값을 테이블의 파티션 개수로 MOD 연산한 결과값에 의해 각 레코드가 저장될 파티션을 결정한다. 즉, 해시 파티션은 테이블에 존재하는 파티션의 개수에 의해 파티션 알고리즘이 변한다. 따라서 **새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 한다.**

```sql
-- 파티션 이름을 지정하여 1개 추가
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
  ADD PARTITION(PARTITION p6 ENGINE=INNODB);

-- 파티션 별도의 이름 없이 6개 추가
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
  ADD PARTITION PARTITIONS 6;
```

해시 파티션에서 파티션을 추가하는 작업은 INPLACE 알고리즘으로 실행된다고 하더라도 레코드 리빌드 작업이 필요하며, 테이블에 대한 읽기 잠금이 필요하다.

→ 많은 부하 발생, 다른 트랜잭션에서 동일 테이블에 데이터 변경 작업(DML) 작업 허용 안됨.

#### 2. 해시 파티션 삭제

해시나 키 파티션은 파티션 단위로 레코드를 삭제하는 방법이 없다.

#### 3. 해시 파티션 분할

해시나 키 파티션에서 특정 파티션을 두 개 이상의 파티션으로 분할하는 기능은 없으며, 테이블 전체적으로 파티션의 개수를 늘리는 것만 가능하다.

#### 4. 해시 파티션 병합

해시나 키 파티션은 2개 이상의 파티션을 하나의 ㅍ타ㅣ션으로 통합하는 기능을 제공하지 않는다. 단지 파티션의 개수를 줄이는 것만 가능하다.

파티션의 개수를 줄일 때는 COALESCE PARTITION 명령을 사용하면 된다.

```sql
-- 파티션 1개 줄이기
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED
  COALESCE PARTITION 1;
```

삭제되는 파티션에 저장돼 있던 레코드가 남은 파티션에 복사되는 것이 아니라, 테이블의 모든 레코드가 재배치되는 작업이 수행된다.

→ INPLACE 알고리즘으로 실행되지만, 테이블의 전체 레코드에 대해 리빌드 작업이 필요하고, 다른 트랜잭션의 데이터 변경이 허용되지 않는다.

#### 5. 해시 파티션 주의사항

- 특정 파티션만 삭제하는 것은 불가능하다.
- 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라, 기존 모든 데이터의 재배치 작업이 필요하다.
- 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리한다. → 해시 파티션이 용도에 적합한 해결책인지 확인이 필요하다.
- 일반적으로 사용자들에게 익숙한 파티션의 조작이나 특성이 대부분 리스트 파티션이나 레인지 파티션에만 해당하는 것들이 많다. → 해시 파티션이나 키 파티션을 사용하거나 조작할 때는 주의가 필요하다.

## 4. 키 파티션

- 해시 파티션과 사용법과 특성이 거의 같다.
- 차이점
  - 해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시한다.
  - 키 파티션에서는 정수 타입이나 정숫값을 반환하는 표현식뿐만 아니라 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있다. MySQL 서버는 선정된 파티션 키의 값을 MD5() 함수를 이용해 해시 값을 계산하고, 그 값을 MOD 연산해서 데이터를 각 파티션에 분배한다.

### (1) 키 파티션의 생성

```sql
CREATE TABLE dept_emp (
  emp_no INT NOT NULL,
  dept_no CHAR(4) NOT NULL,
  ...
  PARIMARY KEY (dept_no, emp_no)
) PARTITION BY KEY(dept_no)
  PARTITIONS 2;
```

- `PARTITION BY KEY()`에 아무 칼럼도 명시하지 않으면, 자동적으로 프라이머리 키나 유니크 키의 모든 칼럼을 파티션 키로 선택한다.

### (2) 키 파티션의 주의사항 및 특이사항

- 키 파티션은 내부적으로 MD5() 함수를 이용해 파티션하기 때문에 파티션 키가 반드시 정수 타입이 아니어도 된다. 해시 파티션으로 파티션이 어렵다면 키 파티션 적용을 고려해보자.
- 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션할 수 있다.
- 유니크 키를 파티션 키로 사용할 때 해당 유니크 키는 반드시 NOT NULL이어야 한다.
- 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 때문에 키 파티션이 더 효율적이다.

## 5. 리니어 해시 파티션/리니어 키 파티션

해시 파티션이나 키 파티션은 새로운 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때, 대상 파티션만이 아니라 테이블의 전체 파티션에 저장된 레코드의 재분배 작업이 발생한다.

리니어 해시 파티션/리니어 키 파티션은 각 레코드 분배를 위해 **Power-of-two(2의 승수)** 알고리즘을 이용하며, 이 알고리즘은 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화한다.

### (1) 리니어 해시 파티션/리니어 키 파티션의 추가 및 통합

리니어 해시 파티션이나 리니어 키 파티션의 경우, Power-of-two 분배 방식을 사용하기 때문에 파티션의 추가나 통합 시 특정 파티션의 데이터에 대해서만 이동 작업을 하면 된다. 그래서 파티션을 추가하거나 통합하는 작업에서 나머지 파티션의 데이터는 재분배 대상이 되지 않는다.

#### 1. 리니어 해시 파티션/리니어 키 파티션의 추가

파티션을 추가하는 명령은 일반 해시 파티션이나 키 파티션과 동일하다.

하지만 Power-of-two 알고리즘으로 레코드가 분배돼 있기 때문에 새로운 파티션을 추가할 때도 특정 파티션의 레코드만 재분배되면 된다. 다른 파티션 데이터는 레코드 재분배 작업과 관련이 없기 때문에 일반 해시 파티션이나 키 파티션의 파티션 추가보다 매우 빠르게 처리할 수 있다.

#### 2. 리니어 해시 파티션/리니어 키 파티션의 통합

파티션을 추가할 때와 같이 일부 파티션에 대해서만 레코드 통합 작업이 필요하다. 통합되는 파티션만 레코드 이동이 필요하며, 나머지 파티션의 레코드는 레코드 재분배 작업에서 제외된다.

#### 3. 리니어 해시 파티션/리니어 키 파티션과 관련된 주의사항

- Power-of-two 알고리즘을 사용하기 때문에 파티션을 추가하거나 통합할 때 작업의 범위를 최소화하는 대신 각 파티션이 가지는 레코드의 건수는 일반 해시 파티션이나 키 파티션보다는 덜 균등해질 수 있다.
- 해시 파티션이나 키 파티션을 사용하는 테이블에 대해 새로운 파티션을 추가하거나 삭제하야 할 요건이 많다면 리니어 해시 파티션 또는 리니어 키 파티션을 적용하는 것이 좋다.
- 파티션을 조정할 필요가 거의 없다면 일반 해시 파티션이나 키 파티션을 사용하는 것이 좋다.

## 6. 파티션 레이블의 쿼리 성능

파티션 테이블에 쿼리가 실행될 때 테이블의 모든 파티션을 읽을지 아니면 일부 파티션만 읽을지는 성능에 아주 큰 영향을 미친다. 쿼리의 성능은 테이블에서 얼마나 많은 파티션을 프루닝할 수 있는지가 관건이다.

- 파티션 프루닝 : 쿼리의 실행 계획이 수립될 때 불필요한 파티션은 모두 배제하고 꼭 필요한 파티션만 걸러내는 과정

테이블을 10개로 파티션해서 10개의 파티션 중에서 주로 1~3개 정도의 파티션만 읽고 쓴다면 파티션 기능이 성능 향상에 도움이 될 것이다. 그런데 10개로 파티션하고 파티션된 10개를 아주 균등하게 사용한다면 이는 성능 향상보다는 오히려 오버헤드만 심해지는 결과를 가져올 수 있다.

대용량 테이블을 10개로 쪼개서 서로 다른 MySQL 서버에 저장(샤딩)한다면 매우 효율적일 것이다. 하지만 MySQL 서버의 파티션은 샤딩이 아니라는 것에 주의하자.

{% hint style="success" %}

파티션을 사용할 때는 반드신 파티션 프루닝이 얼마나 도움이 될지를 먼저 예측해보고 응용 프로그램에 적용하자. 레인지 파티션 이외의 파티션을 적용할 때는 파티션 프루닝을 더 많이 고민해보고 적용할 것을 권장한다.

{% endhint %}
